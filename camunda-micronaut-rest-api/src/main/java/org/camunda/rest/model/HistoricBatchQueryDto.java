/*
 * Camunda Platform REST API
 * OpenApi Spec for Camunda Platform REST API.
 *
 * The version of the OpenAPI document: 7.18.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.camunda.rest.model;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;
import io.micronaut.core.annotation.Introspected;
import io.micronaut.core.annotation.Nullable;

import javax.annotation.Generated;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Query for the historic batches to set the removal time for.
 */
@JsonPropertyOrder({
  HistoricBatchQueryDto.JSON_PROPERTY_BATCH_ID,
  HistoricBatchQueryDto.JSON_PROPERTY_TYPE,
  HistoricBatchQueryDto.JSON_PROPERTY_COMPLETED,
  HistoricBatchQueryDto.JSON_PROPERTY_TENANT_ID_IN,
  HistoricBatchQueryDto.JSON_PROPERTY_WITHOUT_TENANT_ID,
  HistoricBatchQueryDto.JSON_PROPERTY_SORTING
})
@JsonTypeName("HistoricBatchQueryDto")
@Generated(value="org.openapitools.codegen.languages.JavaMicronautClientCodegen")
@Introspected
public class HistoricBatchQueryDto {
    public static final String JSON_PROPERTY_BATCH_ID = "batchId";
    private String batchId;

    public static final String JSON_PROPERTY_TYPE = "type";
    private String type;

    public static final String JSON_PROPERTY_COMPLETED = "completed";
    private Boolean completed;

    public static final String JSON_PROPERTY_TENANT_ID_IN = "tenantIdIn";
    private List<String> tenantIdIn = null;

    public static final String JSON_PROPERTY_WITHOUT_TENANT_ID = "withoutTenantId";
    private Boolean withoutTenantId;

    public static final String JSON_PROPERTY_SORTING = "sorting";
    private List<HistoricBatchQueryDtoSortingInner> sorting = null;

    public HistoricBatchQueryDto() {
    }

    public HistoricBatchQueryDto batchId(String batchId) {
        this.batchId = batchId;
        return this;
    }

    /**
     * Filter by batch id.
     * @return batchId
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_BATCH_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getBatchId() {
        return batchId;
    }

    @JsonProperty(JSON_PROPERTY_BATCH_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setBatchId(String batchId) {
        this.batchId = batchId;
    }

    public HistoricBatchQueryDto type(String type) {
        this.type = type;
        return this;
    }

    /**
     * Filter by batch type. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/batch/#creating-a-batch) for more information about batch types.
     * @return type
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_TYPE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getType() {
        return type;
    }

    @JsonProperty(JSON_PROPERTY_TYPE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setType(String type) {
        this.type = type;
    }

    public HistoricBatchQueryDto completed(Boolean completed) {
        this.completed = completed;
        return this;
    }

    /**
     *  Filter completed or not completed batches. If the value is &#x60;true&#x60;, only completed batches, i.e., end time is set, are returned. Otherwise, if the value is &#x60;false&#x60;, only running batches, i.e., end time is null, are returned.
     * @return completed
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_COMPLETED)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Boolean getCompleted() {
        return completed;
    }

    @JsonProperty(JSON_PROPERTY_COMPLETED)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setCompleted(Boolean completed) {
        this.completed = completed;
    }

    public HistoricBatchQueryDto tenantIdIn(List<String> tenantIdIn) {
        this.tenantIdIn = tenantIdIn;
        return this;
    }

    public HistoricBatchQueryDto addTenantIdInItem(String tenantIdInItem) {
        if (this.tenantIdIn == null) {
            this.tenantIdIn = new ArrayList<>();
        }
        this.tenantIdIn.add(tenantIdInItem);
        return this;
    }

    /**
     * Filter by a comma-separated list of tenant ids. A batch matches if it has one of the given tenant ids.
     * @return tenantIdIn
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_TENANT_ID_IN)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public List<String> getTenantIdIn() {
        return tenantIdIn;
    }

    @JsonProperty(JSON_PROPERTY_TENANT_ID_IN)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setTenantIdIn(List<String> tenantIdIn) {
        this.tenantIdIn = tenantIdIn;
    }

    public HistoricBatchQueryDto withoutTenantId(Boolean withoutTenantId) {
        this.withoutTenantId = withoutTenantId;
        return this;
    }

    /**
     * Only include batches which belong to no tenant. Value can effectively only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @return withoutTenantId
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_WITHOUT_TENANT_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Boolean getWithoutTenantId() {
        return withoutTenantId;
    }

    @JsonProperty(JSON_PROPERTY_WITHOUT_TENANT_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setWithoutTenantId(Boolean withoutTenantId) {
        this.withoutTenantId = withoutTenantId;
    }

    public HistoricBatchQueryDto sorting(List<HistoricBatchQueryDtoSortingInner> sorting) {
        this.sorting = sorting;
        return this;
    }

    public HistoricBatchQueryDto addSortingItem(HistoricBatchQueryDtoSortingInner sortingItem) {
        if (this.sorting == null) {
            this.sorting = new ArrayList<>();
        }
        this.sorting.add(sortingItem);
        return this;
    }

    /**
     * An array of criteria to sort the result by. Each element of the array is                        an object that specifies one ordering. The position in the array                        identifies the rank of an ordering, i.e., whether it is primary, secondary,                        etc. Has no effect for the &#x60;/count&#x60; endpoint
     * @return sorting
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_SORTING)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public List<HistoricBatchQueryDtoSortingInner> getSorting() {
        return sorting;
    }

    @JsonProperty(JSON_PROPERTY_SORTING)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setSorting(List<HistoricBatchQueryDtoSortingInner> sorting) {
        this.sorting = sorting;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        HistoricBatchQueryDto historicBatchQueryDto = (HistoricBatchQueryDto) o;
        return Objects.equals(this.batchId, historicBatchQueryDto.batchId) &&
            Objects.equals(this.type, historicBatchQueryDto.type) &&
            Objects.equals(this.completed, historicBatchQueryDto.completed) &&
            Objects.equals(this.tenantIdIn, historicBatchQueryDto.tenantIdIn) &&
            Objects.equals(this.withoutTenantId, historicBatchQueryDto.withoutTenantId) &&
            Objects.equals(this.sorting, historicBatchQueryDto.sorting);
    }

    @Override
    public int hashCode() {
        return Objects.hash(batchId, type, completed, tenantIdIn, withoutTenantId, sorting);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class HistoricBatchQueryDto {\n");
        sb.append("    batchId: ").append(toIndentedString(batchId)).append("\n");
        sb.append("    type: ").append(toIndentedString(type)).append("\n");
        sb.append("    completed: ").append(toIndentedString(completed)).append("\n");
        sb.append("    tenantIdIn: ").append(toIndentedString(tenantIdIn)).append("\n");
        sb.append("    withoutTenantId: ").append(toIndentedString(withoutTenantId)).append("\n");
        sb.append("    sorting: ").append(toIndentedString(sorting)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }

}

