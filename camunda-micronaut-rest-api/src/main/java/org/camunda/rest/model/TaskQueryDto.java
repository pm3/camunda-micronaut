/*
 * Camunda Platform REST API
 * OpenApi Spec for Camunda Platform REST API.
 *
 * The version of the OpenAPI document: 7.18.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.camunda.rest.model;

import com.fasterxml.jackson.annotation.*;
import io.micronaut.core.annotation.Introspected;
import io.micronaut.core.annotation.Nullable;

import javax.annotation.Generated;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * A Task query which defines a group of Tasks.
 */
@JsonPropertyOrder({
  TaskQueryDto.JSON_PROPERTY_TASK_ID,
  TaskQueryDto.JSON_PROPERTY_TASK_ID_IN,
  TaskQueryDto.JSON_PROPERTY_PROCESS_INSTANCE_ID,
  TaskQueryDto.JSON_PROPERTY_PROCESS_INSTANCE_ID_IN,
  TaskQueryDto.JSON_PROPERTY_PROCESS_INSTANCE_BUSINESS_KEY,
  TaskQueryDto.JSON_PROPERTY_PROCESS_INSTANCE_BUSINESS_KEY_EXPRESSION,
  TaskQueryDto.JSON_PROPERTY_PROCESS_INSTANCE_BUSINESS_KEY_IN,
  TaskQueryDto.JSON_PROPERTY_PROCESS_INSTANCE_BUSINESS_KEY_LIKE,
  TaskQueryDto.JSON_PROPERTY_PROCESS_INSTANCE_BUSINESS_KEY_LIKE_EXPRESSION,
  TaskQueryDto.JSON_PROPERTY_PROCESS_DEFINITION_ID,
  TaskQueryDto.JSON_PROPERTY_PROCESS_DEFINITION_KEY,
  TaskQueryDto.JSON_PROPERTY_PROCESS_DEFINITION_KEY_IN,
  TaskQueryDto.JSON_PROPERTY_PROCESS_DEFINITION_NAME,
  TaskQueryDto.JSON_PROPERTY_PROCESS_DEFINITION_NAME_LIKE,
  TaskQueryDto.JSON_PROPERTY_EXECUTION_ID,
  TaskQueryDto.JSON_PROPERTY_CASE_INSTANCE_ID,
  TaskQueryDto.JSON_PROPERTY_CASE_INSTANCE_BUSINESS_KEY,
  TaskQueryDto.JSON_PROPERTY_CASE_INSTANCE_BUSINESS_KEY_LIKE,
  TaskQueryDto.JSON_PROPERTY_CASE_DEFINITION_ID,
  TaskQueryDto.JSON_PROPERTY_CASE_DEFINITION_KEY,
  TaskQueryDto.JSON_PROPERTY_CASE_DEFINITION_NAME,
  TaskQueryDto.JSON_PROPERTY_CASE_DEFINITION_NAME_LIKE,
  TaskQueryDto.JSON_PROPERTY_CASE_EXECUTION_ID,
  TaskQueryDto.JSON_PROPERTY_ACTIVITY_INSTANCE_ID_IN,
  TaskQueryDto.JSON_PROPERTY_TENANT_ID_IN,
  TaskQueryDto.JSON_PROPERTY_WITHOUT_TENANT_ID,
  TaskQueryDto.JSON_PROPERTY_ASSIGNEE,
  TaskQueryDto.JSON_PROPERTY_ASSIGNEE_EXPRESSION,
  TaskQueryDto.JSON_PROPERTY_ASSIGNEE_LIKE,
  TaskQueryDto.JSON_PROPERTY_ASSIGNEE_LIKE_EXPRESSION,
  TaskQueryDto.JSON_PROPERTY_ASSIGNEE_IN,
  TaskQueryDto.JSON_PROPERTY_ASSIGNEE_NOT_IN,
  TaskQueryDto.JSON_PROPERTY_OWNER,
  TaskQueryDto.JSON_PROPERTY_OWNER_EXPRESSION,
  TaskQueryDto.JSON_PROPERTY_CANDIDATE_GROUP,
  TaskQueryDto.JSON_PROPERTY_CANDIDATE_GROUP_EXPRESSION,
  TaskQueryDto.JSON_PROPERTY_CANDIDATE_USER,
  TaskQueryDto.JSON_PROPERTY_CANDIDATE_USER_EXPRESSION,
  TaskQueryDto.JSON_PROPERTY_INCLUDE_ASSIGNED_TASKS,
  TaskQueryDto.JSON_PROPERTY_INVOLVED_USER,
  TaskQueryDto.JSON_PROPERTY_INVOLVED_USER_EXPRESSION,
  TaskQueryDto.JSON_PROPERTY_ASSIGNED,
  TaskQueryDto.JSON_PROPERTY_UNASSIGNED,
  TaskQueryDto.JSON_PROPERTY_TASK_DEFINITION_KEY,
  TaskQueryDto.JSON_PROPERTY_TASK_DEFINITION_KEY_IN,
  TaskQueryDto.JSON_PROPERTY_TASK_DEFINITION_KEY_LIKE,
  TaskQueryDto.JSON_PROPERTY_NAME,
  TaskQueryDto.JSON_PROPERTY_NAME_NOT_EQUAL,
  TaskQueryDto.JSON_PROPERTY_NAME_LIKE,
  TaskQueryDto.JSON_PROPERTY_NAME_NOT_LIKE,
  TaskQueryDto.JSON_PROPERTY_DESCRIPTION,
  TaskQueryDto.JSON_PROPERTY_DESCRIPTION_LIKE,
  TaskQueryDto.JSON_PROPERTY_PRIORITY,
  TaskQueryDto.JSON_PROPERTY_MAX_PRIORITY,
  TaskQueryDto.JSON_PROPERTY_MIN_PRIORITY,
  TaskQueryDto.JSON_PROPERTY_DUE_DATE,
  TaskQueryDto.JSON_PROPERTY_DUE_DATE_EXPRESSION,
  TaskQueryDto.JSON_PROPERTY_DUE_AFTER,
  TaskQueryDto.JSON_PROPERTY_DUE_AFTER_EXPRESSION,
  TaskQueryDto.JSON_PROPERTY_DUE_BEFORE,
  TaskQueryDto.JSON_PROPERTY_DUE_BEFORE_EXPRESSION,
  TaskQueryDto.JSON_PROPERTY_WITHOUT_DUE_DATE,
  TaskQueryDto.JSON_PROPERTY_FOLLOW_UP_DATE,
  TaskQueryDto.JSON_PROPERTY_FOLLOW_UP_DATE_EXPRESSION,
  TaskQueryDto.JSON_PROPERTY_FOLLOW_UP_AFTER,
  TaskQueryDto.JSON_PROPERTY_FOLLOW_UP_AFTER_EXPRESSION,
  TaskQueryDto.JSON_PROPERTY_FOLLOW_UP_BEFORE,
  TaskQueryDto.JSON_PROPERTY_FOLLOW_UP_BEFORE_EXPRESSION,
  TaskQueryDto.JSON_PROPERTY_FOLLOW_UP_BEFORE_OR_NOT_EXISTENT,
  TaskQueryDto.JSON_PROPERTY_FOLLOW_UP_BEFORE_OR_NOT_EXISTENT_EXPRESSION,
  TaskQueryDto.JSON_PROPERTY_CREATED_ON,
  TaskQueryDto.JSON_PROPERTY_CREATED_ON_EXPRESSION,
  TaskQueryDto.JSON_PROPERTY_CREATED_AFTER,
  TaskQueryDto.JSON_PROPERTY_CREATED_AFTER_EXPRESSION,
  TaskQueryDto.JSON_PROPERTY_CREATED_BEFORE,
  TaskQueryDto.JSON_PROPERTY_CREATED_BEFORE_EXPRESSION,
  TaskQueryDto.JSON_PROPERTY_UPDATED_AFTER,
  TaskQueryDto.JSON_PROPERTY_UPDATED_AFTER_EXPRESSION,
  TaskQueryDto.JSON_PROPERTY_DELEGATION_STATE,
  TaskQueryDto.JSON_PROPERTY_CANDIDATE_GROUPS,
  TaskQueryDto.JSON_PROPERTY_CANDIDATE_GROUPS_EXPRESSION,
  TaskQueryDto.JSON_PROPERTY_WITH_CANDIDATE_GROUPS,
  TaskQueryDto.JSON_PROPERTY_WITHOUT_CANDIDATE_GROUPS,
  TaskQueryDto.JSON_PROPERTY_WITH_CANDIDATE_USERS,
  TaskQueryDto.JSON_PROPERTY_WITHOUT_CANDIDATE_USERS,
  TaskQueryDto.JSON_PROPERTY_ACTIVE,
  TaskQueryDto.JSON_PROPERTY_SUSPENDED,
  TaskQueryDto.JSON_PROPERTY_TASK_VARIABLES,
  TaskQueryDto.JSON_PROPERTY_PROCESS_VARIABLES,
  TaskQueryDto.JSON_PROPERTY_CASE_INSTANCE_VARIABLES,
  TaskQueryDto.JSON_PROPERTY_VARIABLE_NAMES_IGNORE_CASE,
  TaskQueryDto.JSON_PROPERTY_VARIABLE_VALUES_IGNORE_CASE,
  TaskQueryDto.JSON_PROPERTY_PARENT_TASK_ID,
  TaskQueryDto.JSON_PROPERTY_OR_QUERIES,
  TaskQueryDto.JSON_PROPERTY_SORTING
})
@JsonTypeName("TaskQueryDto")
@Generated(value="org.openapitools.codegen.languages.JavaMicronautClientCodegen")
@Introspected
public class TaskQueryDto {
    public static final String JSON_PROPERTY_TASK_ID = "taskId";
    private String taskId;

    public static final String JSON_PROPERTY_TASK_ID_IN = "taskIdIn";
    private List<String> taskIdIn = null;

    public static final String JSON_PROPERTY_PROCESS_INSTANCE_ID = "processInstanceId";
    private String processInstanceId;

    public static final String JSON_PROPERTY_PROCESS_INSTANCE_ID_IN = "processInstanceIdIn";
    private List<String> processInstanceIdIn = null;

    public static final String JSON_PROPERTY_PROCESS_INSTANCE_BUSINESS_KEY = "processInstanceBusinessKey";
    private String processInstanceBusinessKey;

    public static final String JSON_PROPERTY_PROCESS_INSTANCE_BUSINESS_KEY_EXPRESSION = "processInstanceBusinessKeyExpression";
    private String processInstanceBusinessKeyExpression;

    public static final String JSON_PROPERTY_PROCESS_INSTANCE_BUSINESS_KEY_IN = "processInstanceBusinessKeyIn";
    private List<String> processInstanceBusinessKeyIn = null;

    public static final String JSON_PROPERTY_PROCESS_INSTANCE_BUSINESS_KEY_LIKE = "processInstanceBusinessKeyLike";
    private String processInstanceBusinessKeyLike;

    public static final String JSON_PROPERTY_PROCESS_INSTANCE_BUSINESS_KEY_LIKE_EXPRESSION = "processInstanceBusinessKeyLikeExpression";
    private String processInstanceBusinessKeyLikeExpression;

    public static final String JSON_PROPERTY_PROCESS_DEFINITION_ID = "processDefinitionId";
    private String processDefinitionId;

    public static final String JSON_PROPERTY_PROCESS_DEFINITION_KEY = "processDefinitionKey";
    private String processDefinitionKey;

    public static final String JSON_PROPERTY_PROCESS_DEFINITION_KEY_IN = "processDefinitionKeyIn";
    private List<String> processDefinitionKeyIn = null;

    public static final String JSON_PROPERTY_PROCESS_DEFINITION_NAME = "processDefinitionName";
    private String processDefinitionName;

    public static final String JSON_PROPERTY_PROCESS_DEFINITION_NAME_LIKE = "processDefinitionNameLike";
    private String processDefinitionNameLike;

    public static final String JSON_PROPERTY_EXECUTION_ID = "executionId";
    private String executionId;

    public static final String JSON_PROPERTY_CASE_INSTANCE_ID = "caseInstanceId";
    private String caseInstanceId;

    public static final String JSON_PROPERTY_CASE_INSTANCE_BUSINESS_KEY = "caseInstanceBusinessKey";
    private String caseInstanceBusinessKey;

    public static final String JSON_PROPERTY_CASE_INSTANCE_BUSINESS_KEY_LIKE = "caseInstanceBusinessKeyLike";
    private String caseInstanceBusinessKeyLike;

    public static final String JSON_PROPERTY_CASE_DEFINITION_ID = "caseDefinitionId";
    private String caseDefinitionId;

    public static final String JSON_PROPERTY_CASE_DEFINITION_KEY = "caseDefinitionKey";
    private String caseDefinitionKey;

    public static final String JSON_PROPERTY_CASE_DEFINITION_NAME = "caseDefinitionName";
    private String caseDefinitionName;

    public static final String JSON_PROPERTY_CASE_DEFINITION_NAME_LIKE = "caseDefinitionNameLike";
    private String caseDefinitionNameLike;

    public static final String JSON_PROPERTY_CASE_EXECUTION_ID = "caseExecutionId";
    private String caseExecutionId;

    public static final String JSON_PROPERTY_ACTIVITY_INSTANCE_ID_IN = "activityInstanceIdIn";
    private List<String> activityInstanceIdIn = null;

    public static final String JSON_PROPERTY_TENANT_ID_IN = "tenantIdIn";
    private List<String> tenantIdIn = null;

    public static final String JSON_PROPERTY_WITHOUT_TENANT_ID = "withoutTenantId";
    private Boolean withoutTenantId = false;

    public static final String JSON_PROPERTY_ASSIGNEE = "assignee";
    private String assignee;

    public static final String JSON_PROPERTY_ASSIGNEE_EXPRESSION = "assigneeExpression";
    private String assigneeExpression;

    public static final String JSON_PROPERTY_ASSIGNEE_LIKE = "assigneeLike";
    private String assigneeLike;

    public static final String JSON_PROPERTY_ASSIGNEE_LIKE_EXPRESSION = "assigneeLikeExpression";
    private String assigneeLikeExpression;

    public static final String JSON_PROPERTY_ASSIGNEE_IN = "assigneeIn";
    private List<String> assigneeIn = null;

    public static final String JSON_PROPERTY_ASSIGNEE_NOT_IN = "assigneeNotIn";
    private List<String> assigneeNotIn = null;

    public static final String JSON_PROPERTY_OWNER = "owner";
    private String owner;

    public static final String JSON_PROPERTY_OWNER_EXPRESSION = "ownerExpression";
    private String ownerExpression;

    public static final String JSON_PROPERTY_CANDIDATE_GROUP = "candidateGroup";
    private String candidateGroup;

    public static final String JSON_PROPERTY_CANDIDATE_GROUP_EXPRESSION = "candidateGroupExpression";
    private String candidateGroupExpression;

    public static final String JSON_PROPERTY_CANDIDATE_USER = "candidateUser";
    private String candidateUser;

    public static final String JSON_PROPERTY_CANDIDATE_USER_EXPRESSION = "candidateUserExpression";
    private String candidateUserExpression;

    public static final String JSON_PROPERTY_INCLUDE_ASSIGNED_TASKS = "includeAssignedTasks";
    private Boolean includeAssignedTasks = false;

    public static final String JSON_PROPERTY_INVOLVED_USER = "involvedUser";
    private String involvedUser;

    public static final String JSON_PROPERTY_INVOLVED_USER_EXPRESSION = "involvedUserExpression";
    private String involvedUserExpression;

    public static final String JSON_PROPERTY_ASSIGNED = "assigned";
    private Boolean assigned = false;

    public static final String JSON_PROPERTY_UNASSIGNED = "unassigned";
    private Boolean unassigned = false;

    public static final String JSON_PROPERTY_TASK_DEFINITION_KEY = "taskDefinitionKey";
    private String taskDefinitionKey;

    public static final String JSON_PROPERTY_TASK_DEFINITION_KEY_IN = "taskDefinitionKeyIn";
    private List<String> taskDefinitionKeyIn = null;

    public static final String JSON_PROPERTY_TASK_DEFINITION_KEY_LIKE = "taskDefinitionKeyLike";
    private String taskDefinitionKeyLike;

    public static final String JSON_PROPERTY_NAME = "name";
    private String name;

    public static final String JSON_PROPERTY_NAME_NOT_EQUAL = "nameNotEqual";
    private String nameNotEqual;

    public static final String JSON_PROPERTY_NAME_LIKE = "nameLike";
    private String nameLike;

    public static final String JSON_PROPERTY_NAME_NOT_LIKE = "nameNotLike";
    private String nameNotLike;

    public static final String JSON_PROPERTY_DESCRIPTION = "description";
    private String description;

    public static final String JSON_PROPERTY_DESCRIPTION_LIKE = "descriptionLike";
    private String descriptionLike;

    public static final String JSON_PROPERTY_PRIORITY = "priority";
    private Integer priority;

    public static final String JSON_PROPERTY_MAX_PRIORITY = "maxPriority";
    private Integer maxPriority;

    public static final String JSON_PROPERTY_MIN_PRIORITY = "minPriority";
    private Integer minPriority;

    public static final String JSON_PROPERTY_DUE_DATE = "dueDate";
    private OffsetDateTime dueDate;

    public static final String JSON_PROPERTY_DUE_DATE_EXPRESSION = "dueDateExpression";
    private String dueDateExpression;

    public static final String JSON_PROPERTY_DUE_AFTER = "dueAfter";
    private OffsetDateTime dueAfter;

    public static final String JSON_PROPERTY_DUE_AFTER_EXPRESSION = "dueAfterExpression";
    private String dueAfterExpression;

    public static final String JSON_PROPERTY_DUE_BEFORE = "dueBefore";
    private OffsetDateTime dueBefore;

    public static final String JSON_PROPERTY_DUE_BEFORE_EXPRESSION = "dueBeforeExpression";
    private String dueBeforeExpression;

    public static final String JSON_PROPERTY_WITHOUT_DUE_DATE = "withoutDueDate";
    private Boolean withoutDueDate = false;

    public static final String JSON_PROPERTY_FOLLOW_UP_DATE = "followUpDate";
    private OffsetDateTime followUpDate;

    public static final String JSON_PROPERTY_FOLLOW_UP_DATE_EXPRESSION = "followUpDateExpression";
    private String followUpDateExpression;

    public static final String JSON_PROPERTY_FOLLOW_UP_AFTER = "followUpAfter";
    private OffsetDateTime followUpAfter;

    public static final String JSON_PROPERTY_FOLLOW_UP_AFTER_EXPRESSION = "followUpAfterExpression";
    private String followUpAfterExpression;

    public static final String JSON_PROPERTY_FOLLOW_UP_BEFORE = "followUpBefore";
    private String followUpBefore;

    public static final String JSON_PROPERTY_FOLLOW_UP_BEFORE_EXPRESSION = "followUpBeforeExpression";
    private String followUpBeforeExpression;

    public static final String JSON_PROPERTY_FOLLOW_UP_BEFORE_OR_NOT_EXISTENT = "followUpBeforeOrNotExistent";
    private OffsetDateTime followUpBeforeOrNotExistent;

    public static final String JSON_PROPERTY_FOLLOW_UP_BEFORE_OR_NOT_EXISTENT_EXPRESSION = "followUpBeforeOrNotExistentExpression";
    private String followUpBeforeOrNotExistentExpression;

    public static final String JSON_PROPERTY_CREATED_ON = "createdOn";
    private OffsetDateTime createdOn;

    public static final String JSON_PROPERTY_CREATED_ON_EXPRESSION = "createdOnExpression";
    private String createdOnExpression;

    public static final String JSON_PROPERTY_CREATED_AFTER = "createdAfter";
    private OffsetDateTime createdAfter;

    public static final String JSON_PROPERTY_CREATED_AFTER_EXPRESSION = "createdAfterExpression";
    private String createdAfterExpression;

    public static final String JSON_PROPERTY_CREATED_BEFORE = "createdBefore";
    private OffsetDateTime createdBefore;

    public static final String JSON_PROPERTY_CREATED_BEFORE_EXPRESSION = "createdBeforeExpression";
    private String createdBeforeExpression;

    public static final String JSON_PROPERTY_UPDATED_AFTER = "updatedAfter";
    private OffsetDateTime updatedAfter;

    public static final String JSON_PROPERTY_UPDATED_AFTER_EXPRESSION = "updatedAfterExpression";
    private String updatedAfterExpression;

    /**
     * Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
     */
    public enum DelegationStateEnum {
        PENDING("PENDING"),
        RESOLVED("RESOLVED");

        private String value;

        DelegationStateEnum(String value) {
            this.value = value;
        }

        @JsonValue
        public String getValue() {
            return value;
        }

        @Override
        public String toString() {
            return String.valueOf(value);
        }

        @JsonCreator
        public static DelegationStateEnum fromValue(String value) {
            for (DelegationStateEnum b : DelegationStateEnum.values()) {
                if (b.value.equals(value)) {
                    return b;
                }
            }
            return null;
        }
    }
    public static final String JSON_PROPERTY_DELEGATION_STATE = "delegationState";
    private DelegationStateEnum delegationState;

    public static final String JSON_PROPERTY_CANDIDATE_GROUPS = "candidateGroups";
    private List<String> candidateGroups = null;

    public static final String JSON_PROPERTY_CANDIDATE_GROUPS_EXPRESSION = "candidateGroupsExpression";
    private String candidateGroupsExpression;

    public static final String JSON_PROPERTY_WITH_CANDIDATE_GROUPS = "withCandidateGroups";
    private Boolean withCandidateGroups = false;

    public static final String JSON_PROPERTY_WITHOUT_CANDIDATE_GROUPS = "withoutCandidateGroups";
    private Boolean withoutCandidateGroups = false;

    public static final String JSON_PROPERTY_WITH_CANDIDATE_USERS = "withCandidateUsers";
    private Boolean withCandidateUsers = false;

    public static final String JSON_PROPERTY_WITHOUT_CANDIDATE_USERS = "withoutCandidateUsers";
    private Boolean withoutCandidateUsers = false;

    public static final String JSON_PROPERTY_ACTIVE = "active";
    private Boolean active = false;

    public static final String JSON_PROPERTY_SUSPENDED = "suspended";
    private Boolean suspended = false;

    public static final String JSON_PROPERTY_TASK_VARIABLES = "taskVariables";
    private List<VariableQueryParameterDto> taskVariables = null;

    public static final String JSON_PROPERTY_PROCESS_VARIABLES = "processVariables";
    private List<VariableQueryParameterDto> processVariables = null;

    public static final String JSON_PROPERTY_CASE_INSTANCE_VARIABLES = "caseInstanceVariables";
    private List<VariableQueryParameterDto> caseInstanceVariables = null;

    public static final String JSON_PROPERTY_VARIABLE_NAMES_IGNORE_CASE = "variableNamesIgnoreCase";
    private Boolean variableNamesIgnoreCase = false;

    public static final String JSON_PROPERTY_VARIABLE_VALUES_IGNORE_CASE = "variableValuesIgnoreCase";
    private Boolean variableValuesIgnoreCase = false;

    public static final String JSON_PROPERTY_PARENT_TASK_ID = "parentTaskId";
    private String parentTaskId;

    public static final String JSON_PROPERTY_OR_QUERIES = "orQueries";
    private List<TaskQueryDto> orQueries = null;

    public static final String JSON_PROPERTY_SORTING = "sorting";
    private List<TaskQueryDtoSortingInner> sorting = null;

    public TaskQueryDto() {
    }

    public TaskQueryDto taskId(String taskId) {
        this.taskId = taskId;
        return this;
    }

    /**
     * Restrict to task with the given id.
     * @return taskId
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_TASK_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getTaskId() {
        return taskId;
    }

    @JsonProperty(JSON_PROPERTY_TASK_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setTaskId(String taskId) {
        this.taskId = taskId;
    }

    public TaskQueryDto taskIdIn(List<String> taskIdIn) {
        this.taskIdIn = taskIdIn;
        return this;
    }

    public TaskQueryDto addTaskIdInItem(String taskIdInItem) {
        if (this.taskIdIn == null) {
            this.taskIdIn = new ArrayList<>();
        }
        this.taskIdIn.add(taskIdInItem);
        return this;
    }

    /**
     * Restrict to tasks with any of the given ids.
     * @return taskIdIn
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_TASK_ID_IN)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public List<String> getTaskIdIn() {
        return taskIdIn;
    }

    @JsonProperty(JSON_PROPERTY_TASK_ID_IN)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setTaskIdIn(List<String> taskIdIn) {
        this.taskIdIn = taskIdIn;
    }

    public TaskQueryDto processInstanceId(String processInstanceId) {
        this.processInstanceId = processInstanceId;
        return this;
    }

    /**
     * Restrict to tasks that belong to process instances with the given id.
     * @return processInstanceId
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_PROCESS_INSTANCE_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getProcessInstanceId() {
        return processInstanceId;
    }

    @JsonProperty(JSON_PROPERTY_PROCESS_INSTANCE_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setProcessInstanceId(String processInstanceId) {
        this.processInstanceId = processInstanceId;
    }

    public TaskQueryDto processInstanceIdIn(List<String> processInstanceIdIn) {
        this.processInstanceIdIn = processInstanceIdIn;
        return this;
    }

    public TaskQueryDto addProcessInstanceIdInItem(String processInstanceIdInItem) {
        if (this.processInstanceIdIn == null) {
            this.processInstanceIdIn = new ArrayList<>();
        }
        this.processInstanceIdIn.add(processInstanceIdInItem);
        return this;
    }

    /**
     * Restrict to tasks that belong to process instances with the given ids.
     * @return processInstanceIdIn
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_PROCESS_INSTANCE_ID_IN)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public List<String> getProcessInstanceIdIn() {
        return processInstanceIdIn;
    }

    @JsonProperty(JSON_PROPERTY_PROCESS_INSTANCE_ID_IN)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setProcessInstanceIdIn(List<String> processInstanceIdIn) {
        this.processInstanceIdIn = processInstanceIdIn;
    }

    public TaskQueryDto processInstanceBusinessKey(String processInstanceBusinessKey) {
        this.processInstanceBusinessKey = processInstanceBusinessKey;
        return this;
    }

    /**
     * Restrict to tasks that belong to process instances with the given business key.
     * @return processInstanceBusinessKey
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_PROCESS_INSTANCE_BUSINESS_KEY)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getProcessInstanceBusinessKey() {
        return processInstanceBusinessKey;
    }

    @JsonProperty(JSON_PROPERTY_PROCESS_INSTANCE_BUSINESS_KEY)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setProcessInstanceBusinessKey(String processInstanceBusinessKey) {
        this.processInstanceBusinessKey = processInstanceBusinessKey;
    }

    public TaskQueryDto processInstanceBusinessKeyExpression(String processInstanceBusinessKeyExpression) {
        this.processInstanceBusinessKeyExpression = processInstanceBusinessKeyExpression;
        return this;
    }

    /**
     * Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @return processInstanceBusinessKeyExpression
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_PROCESS_INSTANCE_BUSINESS_KEY_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getProcessInstanceBusinessKeyExpression() {
        return processInstanceBusinessKeyExpression;
    }

    @JsonProperty(JSON_PROPERTY_PROCESS_INSTANCE_BUSINESS_KEY_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setProcessInstanceBusinessKeyExpression(String processInstanceBusinessKeyExpression) {
        this.processInstanceBusinessKeyExpression = processInstanceBusinessKeyExpression;
    }

    public TaskQueryDto processInstanceBusinessKeyIn(List<String> processInstanceBusinessKeyIn) {
        this.processInstanceBusinessKeyIn = processInstanceBusinessKeyIn;
        return this;
    }

    public TaskQueryDto addProcessInstanceBusinessKeyInItem(String processInstanceBusinessKeyInItem) {
        if (this.processInstanceBusinessKeyIn == null) {
            this.processInstanceBusinessKeyIn = new ArrayList<>();
        }
        this.processInstanceBusinessKeyIn.add(processInstanceBusinessKeyInItem);
        return this;
    }

    /**
     * Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
     * @return processInstanceBusinessKeyIn
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_PROCESS_INSTANCE_BUSINESS_KEY_IN)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public List<String> getProcessInstanceBusinessKeyIn() {
        return processInstanceBusinessKeyIn;
    }

    @JsonProperty(JSON_PROPERTY_PROCESS_INSTANCE_BUSINESS_KEY_IN)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setProcessInstanceBusinessKeyIn(List<String> processInstanceBusinessKeyIn) {
        this.processInstanceBusinessKeyIn = processInstanceBusinessKeyIn;
    }

    public TaskQueryDto processInstanceBusinessKeyLike(String processInstanceBusinessKeyLike) {
        this.processInstanceBusinessKeyLike = processInstanceBusinessKeyLike;
        return this;
    }

    /**
     * Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
     * @return processInstanceBusinessKeyLike
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_PROCESS_INSTANCE_BUSINESS_KEY_LIKE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getProcessInstanceBusinessKeyLike() {
        return processInstanceBusinessKeyLike;
    }

    @JsonProperty(JSON_PROPERTY_PROCESS_INSTANCE_BUSINESS_KEY_LIKE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setProcessInstanceBusinessKeyLike(String processInstanceBusinessKeyLike) {
        this.processInstanceBusinessKeyLike = processInstanceBusinessKeyLike;
    }

    public TaskQueryDto processInstanceBusinessKeyLikeExpression(String processInstanceBusinessKeyLikeExpression) {
        this.processInstanceBusinessKeyLikeExpression = processInstanceBusinessKeyLikeExpression;
        return this;
    }

    /**
     * Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @return processInstanceBusinessKeyLikeExpression
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_PROCESS_INSTANCE_BUSINESS_KEY_LIKE_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getProcessInstanceBusinessKeyLikeExpression() {
        return processInstanceBusinessKeyLikeExpression;
    }

    @JsonProperty(JSON_PROPERTY_PROCESS_INSTANCE_BUSINESS_KEY_LIKE_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setProcessInstanceBusinessKeyLikeExpression(String processInstanceBusinessKeyLikeExpression) {
        this.processInstanceBusinessKeyLikeExpression = processInstanceBusinessKeyLikeExpression;
    }

    public TaskQueryDto processDefinitionId(String processDefinitionId) {
        this.processDefinitionId = processDefinitionId;
        return this;
    }

    /**
     * Restrict to tasks that belong to a process definition with the given id.
     * @return processDefinitionId
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_PROCESS_DEFINITION_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getProcessDefinitionId() {
        return processDefinitionId;
    }

    @JsonProperty(JSON_PROPERTY_PROCESS_DEFINITION_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setProcessDefinitionId(String processDefinitionId) {
        this.processDefinitionId = processDefinitionId;
    }

    public TaskQueryDto processDefinitionKey(String processDefinitionKey) {
        this.processDefinitionKey = processDefinitionKey;
        return this;
    }

    /**
     * Restrict to tasks that belong to a process definition with the given key.
     * @return processDefinitionKey
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_PROCESS_DEFINITION_KEY)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getProcessDefinitionKey() {
        return processDefinitionKey;
    }

    @JsonProperty(JSON_PROPERTY_PROCESS_DEFINITION_KEY)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setProcessDefinitionKey(String processDefinitionKey) {
        this.processDefinitionKey = processDefinitionKey;
    }

    public TaskQueryDto processDefinitionKeyIn(List<String> processDefinitionKeyIn) {
        this.processDefinitionKeyIn = processDefinitionKeyIn;
        return this;
    }

    public TaskQueryDto addProcessDefinitionKeyInItem(String processDefinitionKeyInItem) {
        if (this.processDefinitionKeyIn == null) {
            this.processDefinitionKeyIn = new ArrayList<>();
        }
        this.processDefinitionKeyIn.add(processDefinitionKeyInItem);
        return this;
    }

    /**
     * Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
     * @return processDefinitionKeyIn
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_PROCESS_DEFINITION_KEY_IN)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public List<String> getProcessDefinitionKeyIn() {
        return processDefinitionKeyIn;
    }

    @JsonProperty(JSON_PROPERTY_PROCESS_DEFINITION_KEY_IN)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setProcessDefinitionKeyIn(List<String> processDefinitionKeyIn) {
        this.processDefinitionKeyIn = processDefinitionKeyIn;
    }

    public TaskQueryDto processDefinitionName(String processDefinitionName) {
        this.processDefinitionName = processDefinitionName;
        return this;
    }

    /**
     * Restrict to tasks that belong to a process definition with the given name.
     * @return processDefinitionName
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_PROCESS_DEFINITION_NAME)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getProcessDefinitionName() {
        return processDefinitionName;
    }

    @JsonProperty(JSON_PROPERTY_PROCESS_DEFINITION_NAME)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setProcessDefinitionName(String processDefinitionName) {
        this.processDefinitionName = processDefinitionName;
    }

    public TaskQueryDto processDefinitionNameLike(String processDefinitionNameLike) {
        this.processDefinitionNameLike = processDefinitionNameLike;
        return this;
    }

    /**
     * Restrict to tasks that have a process definition name that has the parameter value as  a substring.
     * @return processDefinitionNameLike
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_PROCESS_DEFINITION_NAME_LIKE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getProcessDefinitionNameLike() {
        return processDefinitionNameLike;
    }

    @JsonProperty(JSON_PROPERTY_PROCESS_DEFINITION_NAME_LIKE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setProcessDefinitionNameLike(String processDefinitionNameLike) {
        this.processDefinitionNameLike = processDefinitionNameLike;
    }

    public TaskQueryDto executionId(String executionId) {
        this.executionId = executionId;
        return this;
    }

    /**
     * Restrict to tasks that belong to an execution with the given id.
     * @return executionId
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_EXECUTION_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getExecutionId() {
        return executionId;
    }

    @JsonProperty(JSON_PROPERTY_EXECUTION_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setExecutionId(String executionId) {
        this.executionId = executionId;
    }

    public TaskQueryDto caseInstanceId(String caseInstanceId) {
        this.caseInstanceId = caseInstanceId;
        return this;
    }

    /**
     * Restrict to tasks that belong to case instances with the given id.
     * @return caseInstanceId
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CASE_INSTANCE_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getCaseInstanceId() {
        return caseInstanceId;
    }

    @JsonProperty(JSON_PROPERTY_CASE_INSTANCE_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setCaseInstanceId(String caseInstanceId) {
        this.caseInstanceId = caseInstanceId;
    }

    public TaskQueryDto caseInstanceBusinessKey(String caseInstanceBusinessKey) {
        this.caseInstanceBusinessKey = caseInstanceBusinessKey;
        return this;
    }

    /**
     * Restrict to tasks that belong to case instances with the given business key.
     * @return caseInstanceBusinessKey
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CASE_INSTANCE_BUSINESS_KEY)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getCaseInstanceBusinessKey() {
        return caseInstanceBusinessKey;
    }

    @JsonProperty(JSON_PROPERTY_CASE_INSTANCE_BUSINESS_KEY)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setCaseInstanceBusinessKey(String caseInstanceBusinessKey) {
        this.caseInstanceBusinessKey = caseInstanceBusinessKey;
    }

    public TaskQueryDto caseInstanceBusinessKeyLike(String caseInstanceBusinessKeyLike) {
        this.caseInstanceBusinessKeyLike = caseInstanceBusinessKeyLike;
        return this;
    }

    /**
     * Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
     * @return caseInstanceBusinessKeyLike
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CASE_INSTANCE_BUSINESS_KEY_LIKE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getCaseInstanceBusinessKeyLike() {
        return caseInstanceBusinessKeyLike;
    }

    @JsonProperty(JSON_PROPERTY_CASE_INSTANCE_BUSINESS_KEY_LIKE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setCaseInstanceBusinessKeyLike(String caseInstanceBusinessKeyLike) {
        this.caseInstanceBusinessKeyLike = caseInstanceBusinessKeyLike;
    }

    public TaskQueryDto caseDefinitionId(String caseDefinitionId) {
        this.caseDefinitionId = caseDefinitionId;
        return this;
    }

    /**
     * Restrict to tasks that belong to a case definition with the given id.
     * @return caseDefinitionId
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CASE_DEFINITION_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getCaseDefinitionId() {
        return caseDefinitionId;
    }

    @JsonProperty(JSON_PROPERTY_CASE_DEFINITION_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setCaseDefinitionId(String caseDefinitionId) {
        this.caseDefinitionId = caseDefinitionId;
    }

    public TaskQueryDto caseDefinitionKey(String caseDefinitionKey) {
        this.caseDefinitionKey = caseDefinitionKey;
        return this;
    }

    /**
     * Restrict to tasks that belong to a case definition with the given key.
     * @return caseDefinitionKey
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CASE_DEFINITION_KEY)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getCaseDefinitionKey() {
        return caseDefinitionKey;
    }

    @JsonProperty(JSON_PROPERTY_CASE_DEFINITION_KEY)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setCaseDefinitionKey(String caseDefinitionKey) {
        this.caseDefinitionKey = caseDefinitionKey;
    }

    public TaskQueryDto caseDefinitionName(String caseDefinitionName) {
        this.caseDefinitionName = caseDefinitionName;
        return this;
    }

    /**
     * Restrict to tasks that belong to a case definition with the given name.
     * @return caseDefinitionName
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CASE_DEFINITION_NAME)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getCaseDefinitionName() {
        return caseDefinitionName;
    }

    @JsonProperty(JSON_PROPERTY_CASE_DEFINITION_NAME)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setCaseDefinitionName(String caseDefinitionName) {
        this.caseDefinitionName = caseDefinitionName;
    }

    public TaskQueryDto caseDefinitionNameLike(String caseDefinitionNameLike) {
        this.caseDefinitionNameLike = caseDefinitionNameLike;
        return this;
    }

    /**
     * Restrict to tasks that have a case definition name that has the parameter value as a  substring.
     * @return caseDefinitionNameLike
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CASE_DEFINITION_NAME_LIKE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getCaseDefinitionNameLike() {
        return caseDefinitionNameLike;
    }

    @JsonProperty(JSON_PROPERTY_CASE_DEFINITION_NAME_LIKE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setCaseDefinitionNameLike(String caseDefinitionNameLike) {
        this.caseDefinitionNameLike = caseDefinitionNameLike;
    }

    public TaskQueryDto caseExecutionId(String caseExecutionId) {
        this.caseExecutionId = caseExecutionId;
        return this;
    }

    /**
     * Restrict to tasks that belong to a case execution with the given id.
     * @return caseExecutionId
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CASE_EXECUTION_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getCaseExecutionId() {
        return caseExecutionId;
    }

    @JsonProperty(JSON_PROPERTY_CASE_EXECUTION_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setCaseExecutionId(String caseExecutionId) {
        this.caseExecutionId = caseExecutionId;
    }

    public TaskQueryDto activityInstanceIdIn(List<String> activityInstanceIdIn) {
        this.activityInstanceIdIn = activityInstanceIdIn;
        return this;
    }

    public TaskQueryDto addActivityInstanceIdInItem(String activityInstanceIdInItem) {
        if (this.activityInstanceIdIn == null) {
            this.activityInstanceIdIn = new ArrayList<>();
        }
        this.activityInstanceIdIn.add(activityInstanceIdInItem);
        return this;
    }

    /**
     * Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
     * @return activityInstanceIdIn
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_ACTIVITY_INSTANCE_ID_IN)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public List<String> getActivityInstanceIdIn() {
        return activityInstanceIdIn;
    }

    @JsonProperty(JSON_PROPERTY_ACTIVITY_INSTANCE_ID_IN)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setActivityInstanceIdIn(List<String> activityInstanceIdIn) {
        this.activityInstanceIdIn = activityInstanceIdIn;
    }

    public TaskQueryDto tenantIdIn(List<String> tenantIdIn) {
        this.tenantIdIn = tenantIdIn;
        return this;
    }

    public TaskQueryDto addTenantIdInItem(String tenantIdInItem) {
        if (this.tenantIdIn == null) {
            this.tenantIdIn = new ArrayList<>();
        }
        this.tenantIdIn.add(tenantIdInItem);
        return this;
    }

    /**
     * Only include tasks which belong to one of the passed and comma-separated  tenant ids.
     * @return tenantIdIn
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_TENANT_ID_IN)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public List<String> getTenantIdIn() {
        return tenantIdIn;
    }

    @JsonProperty(JSON_PROPERTY_TENANT_ID_IN)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setTenantIdIn(List<String> tenantIdIn) {
        this.tenantIdIn = tenantIdIn;
    }

    public TaskQueryDto withoutTenantId(Boolean withoutTenantId) {
        this.withoutTenantId = withoutTenantId;
        return this;
    }

    /**
     * Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
     * @return withoutTenantId
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_WITHOUT_TENANT_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Boolean getWithoutTenantId() {
        return withoutTenantId;
    }

    @JsonProperty(JSON_PROPERTY_WITHOUT_TENANT_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setWithoutTenantId(Boolean withoutTenantId) {
        this.withoutTenantId = withoutTenantId;
    }

    public TaskQueryDto assignee(String assignee) {
        this.assignee = assignee;
        return this;
    }

    /**
     * Restrict to tasks that the given user is assigned to.
     * @return assignee
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_ASSIGNEE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getAssignee() {
        return assignee;
    }

    @JsonProperty(JSON_PROPERTY_ASSIGNEE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setAssignee(String assignee) {
        this.assignee = assignee;
    }

    public TaskQueryDto assigneeExpression(String assigneeExpression) {
        this.assigneeExpression = assigneeExpression;
        return this;
    }

    /**
     * Restrict to tasks that the user described by the given expression is assigned to. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @return assigneeExpression
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_ASSIGNEE_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getAssigneeExpression() {
        return assigneeExpression;
    }

    @JsonProperty(JSON_PROPERTY_ASSIGNEE_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setAssigneeExpression(String assigneeExpression) {
        this.assigneeExpression = assigneeExpression;
    }

    public TaskQueryDto assigneeLike(String assigneeLike) {
        this.assigneeLike = assigneeLike;
        return this;
    }

    /**
     * Restrict to tasks that have an assignee that has the parameter  value as a substring.
     * @return assigneeLike
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_ASSIGNEE_LIKE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getAssigneeLike() {
        return assigneeLike;
    }

    @JsonProperty(JSON_PROPERTY_ASSIGNEE_LIKE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setAssigneeLike(String assigneeLike) {
        this.assigneeLike = assigneeLike;
    }

    public TaskQueryDto assigneeLikeExpression(String assigneeLikeExpression) {
        this.assigneeLikeExpression = assigneeLikeExpression;
        return this;
    }

    /**
     * Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @return assigneeLikeExpression
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_ASSIGNEE_LIKE_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getAssigneeLikeExpression() {
        return assigneeLikeExpression;
    }

    @JsonProperty(JSON_PROPERTY_ASSIGNEE_LIKE_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setAssigneeLikeExpression(String assigneeLikeExpression) {
        this.assigneeLikeExpression = assigneeLikeExpression;
    }

    public TaskQueryDto assigneeIn(List<String> assigneeIn) {
        this.assigneeIn = assigneeIn;
        return this;
    }

    public TaskQueryDto addAssigneeInItem(String assigneeInItem) {
        if (this.assigneeIn == null) {
            this.assigneeIn = new ArrayList<>();
        }
        this.assigneeIn.add(assigneeInItem);
        return this;
    }

    /**
     * Only include tasks which are assigned to one of the passed and comma-separated user ids.
     * @return assigneeIn
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_ASSIGNEE_IN)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public List<String> getAssigneeIn() {
        return assigneeIn;
    }

    @JsonProperty(JSON_PROPERTY_ASSIGNEE_IN)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setAssigneeIn(List<String> assigneeIn) {
        this.assigneeIn = assigneeIn;
    }

    public TaskQueryDto assigneeNotIn(List<String> assigneeNotIn) {
        this.assigneeNotIn = assigneeNotIn;
        return this;
    }

    public TaskQueryDto addAssigneeNotInItem(String assigneeNotInItem) {
        if (this.assigneeNotIn == null) {
            this.assigneeNotIn = new ArrayList<>();
        }
        this.assigneeNotIn.add(assigneeNotInItem);
        return this;
    }

    /**
     * Only include tasks which are not assigned to one of the passed and comma-separated user ids.
     * @return assigneeNotIn
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_ASSIGNEE_NOT_IN)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public List<String> getAssigneeNotIn() {
        return assigneeNotIn;
    }

    @JsonProperty(JSON_PROPERTY_ASSIGNEE_NOT_IN)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setAssigneeNotIn(List<String> assigneeNotIn) {
        this.assigneeNotIn = assigneeNotIn;
    }

    public TaskQueryDto owner(String owner) {
        this.owner = owner;
        return this;
    }

    /**
     * Restrict to tasks that the given user owns.
     * @return owner
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_OWNER)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getOwner() {
        return owner;
    }

    @JsonProperty(JSON_PROPERTY_OWNER)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setOwner(String owner) {
        this.owner = owner;
    }

    public TaskQueryDto ownerExpression(String ownerExpression) {
        this.ownerExpression = ownerExpression;
        return this;
    }

    /**
     * Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @return ownerExpression
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_OWNER_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getOwnerExpression() {
        return ownerExpression;
    }

    @JsonProperty(JSON_PROPERTY_OWNER_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setOwnerExpression(String ownerExpression) {
        this.ownerExpression = ownerExpression;
    }

    public TaskQueryDto candidateGroup(String candidateGroup) {
        this.candidateGroup = candidateGroup;
        return this;
    }

    /**
     * Only include tasks that are offered to the given group.
     * @return candidateGroup
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CANDIDATE_GROUP)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getCandidateGroup() {
        return candidateGroup;
    }

    @JsonProperty(JSON_PROPERTY_CANDIDATE_GROUP)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setCandidateGroup(String candidateGroup) {
        this.candidateGroup = candidateGroup;
    }

    public TaskQueryDto candidateGroupExpression(String candidateGroupExpression) {
        this.candidateGroupExpression = candidateGroupExpression;
        return this;
    }

    /**
     * Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @return candidateGroupExpression
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CANDIDATE_GROUP_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getCandidateGroupExpression() {
        return candidateGroupExpression;
    }

    @JsonProperty(JSON_PROPERTY_CANDIDATE_GROUP_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setCandidateGroupExpression(String candidateGroupExpression) {
        this.candidateGroupExpression = candidateGroupExpression;
    }

    public TaskQueryDto candidateUser(String candidateUser) {
        this.candidateUser = candidateUser;
        return this;
    }

    /**
     * Only include tasks that are offered to the given user or to one of his groups.
     * @return candidateUser
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CANDIDATE_USER)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getCandidateUser() {
        return candidateUser;
    }

    @JsonProperty(JSON_PROPERTY_CANDIDATE_USER)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setCandidateUser(String candidateUser) {
        this.candidateUser = candidateUser;
    }

    public TaskQueryDto candidateUserExpression(String candidateUserExpression) {
        this.candidateUserExpression = candidateUserExpression;
        return this;
    }

    /**
     * Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @return candidateUserExpression
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CANDIDATE_USER_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getCandidateUserExpression() {
        return candidateUserExpression;
    }

    @JsonProperty(JSON_PROPERTY_CANDIDATE_USER_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setCandidateUserExpression(String candidateUserExpression) {
        this.candidateUserExpression = candidateUserExpression;
    }

    public TaskQueryDto includeAssignedTasks(Boolean includeAssignedTasks) {
        this.includeAssignedTasks = includeAssignedTasks;
        return this;
    }

    /**
     * Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
     * @return includeAssignedTasks
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_INCLUDE_ASSIGNED_TASKS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Boolean getIncludeAssignedTasks() {
        return includeAssignedTasks;
    }

    @JsonProperty(JSON_PROPERTY_INCLUDE_ASSIGNED_TASKS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setIncludeAssignedTasks(Boolean includeAssignedTasks) {
        this.includeAssignedTasks = includeAssignedTasks;
    }

    public TaskQueryDto involvedUser(String involvedUser) {
        this.involvedUser = involvedUser;
        return this;
    }

    /**
     * Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
     * @return involvedUser
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_INVOLVED_USER)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getInvolvedUser() {
        return involvedUser;
    }

    @JsonProperty(JSON_PROPERTY_INVOLVED_USER)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setInvolvedUser(String involvedUser) {
        this.involvedUser = involvedUser;
    }

    public TaskQueryDto involvedUserExpression(String involvedUserExpression) {
        this.involvedUserExpression = involvedUserExpression;
        return this;
    }

    /**
     * Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @return involvedUserExpression
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_INVOLVED_USER_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getInvolvedUserExpression() {
        return involvedUserExpression;
    }

    @JsonProperty(JSON_PROPERTY_INVOLVED_USER_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setInvolvedUserExpression(String involvedUserExpression) {
        this.involvedUserExpression = involvedUserExpression;
    }

    public TaskQueryDto assigned(Boolean assigned) {
        this.assigned = assigned;
        return this;
    }

    /**
     * If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
     * @return assigned
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_ASSIGNED)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Boolean getAssigned() {
        return assigned;
    }

    @JsonProperty(JSON_PROPERTY_ASSIGNED)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setAssigned(Boolean assigned) {
        this.assigned = assigned;
    }

    public TaskQueryDto unassigned(Boolean unassigned) {
        this.unassigned = unassigned;
        return this;
    }

    /**
     * If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
     * @return unassigned
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_UNASSIGNED)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Boolean getUnassigned() {
        return unassigned;
    }

    @JsonProperty(JSON_PROPERTY_UNASSIGNED)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setUnassigned(Boolean unassigned) {
        this.unassigned = unassigned;
    }

    public TaskQueryDto taskDefinitionKey(String taskDefinitionKey) {
        this.taskDefinitionKey = taskDefinitionKey;
        return this;
    }

    /**
     * Restrict to tasks that have the given key.
     * @return taskDefinitionKey
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_TASK_DEFINITION_KEY)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getTaskDefinitionKey() {
        return taskDefinitionKey;
    }

    @JsonProperty(JSON_PROPERTY_TASK_DEFINITION_KEY)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setTaskDefinitionKey(String taskDefinitionKey) {
        this.taskDefinitionKey = taskDefinitionKey;
    }

    public TaskQueryDto taskDefinitionKeyIn(List<String> taskDefinitionKeyIn) {
        this.taskDefinitionKeyIn = taskDefinitionKeyIn;
        return this;
    }

    public TaskQueryDto addTaskDefinitionKeyInItem(String taskDefinitionKeyInItem) {
        if (this.taskDefinitionKeyIn == null) {
            this.taskDefinitionKeyIn = new ArrayList<>();
        }
        this.taskDefinitionKeyIn.add(taskDefinitionKeyInItem);
        return this;
    }

    /**
     * Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
     * @return taskDefinitionKeyIn
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_TASK_DEFINITION_KEY_IN)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public List<String> getTaskDefinitionKeyIn() {
        return taskDefinitionKeyIn;
    }

    @JsonProperty(JSON_PROPERTY_TASK_DEFINITION_KEY_IN)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setTaskDefinitionKeyIn(List<String> taskDefinitionKeyIn) {
        this.taskDefinitionKeyIn = taskDefinitionKeyIn;
    }

    public TaskQueryDto taskDefinitionKeyLike(String taskDefinitionKeyLike) {
        this.taskDefinitionKeyLike = taskDefinitionKeyLike;
        return this;
    }

    /**
     * Restrict to tasks that have a key that has the parameter value as a substring.
     * @return taskDefinitionKeyLike
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_TASK_DEFINITION_KEY_LIKE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getTaskDefinitionKeyLike() {
        return taskDefinitionKeyLike;
    }

    @JsonProperty(JSON_PROPERTY_TASK_DEFINITION_KEY_LIKE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setTaskDefinitionKeyLike(String taskDefinitionKeyLike) {
        this.taskDefinitionKeyLike = taskDefinitionKeyLike;
    }

    public TaskQueryDto name(String name) {
        this.name = name;
        return this;
    }

    /**
     * Restrict to tasks that have the given name.
     * @return name
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_NAME)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getName() {
        return name;
    }

    @JsonProperty(JSON_PROPERTY_NAME)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setName(String name) {
        this.name = name;
    }

    public TaskQueryDto nameNotEqual(String nameNotEqual) {
        this.nameNotEqual = nameNotEqual;
        return this;
    }

    /**
     * Restrict to tasks that do not have the given name.
     * @return nameNotEqual
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_NAME_NOT_EQUAL)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getNameNotEqual() {
        return nameNotEqual;
    }

    @JsonProperty(JSON_PROPERTY_NAME_NOT_EQUAL)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setNameNotEqual(String nameNotEqual) {
        this.nameNotEqual = nameNotEqual;
    }

    public TaskQueryDto nameLike(String nameLike) {
        this.nameLike = nameLike;
        return this;
    }

    /**
     * Restrict to tasks that have a name with the given parameter value as substring.
     * @return nameLike
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_NAME_LIKE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getNameLike() {
        return nameLike;
    }

    @JsonProperty(JSON_PROPERTY_NAME_LIKE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setNameLike(String nameLike) {
        this.nameLike = nameLike;
    }

    public TaskQueryDto nameNotLike(String nameNotLike) {
        this.nameNotLike = nameNotLike;
        return this;
    }

    /**
     * Restrict to tasks that do not have a name with the given parameter value as substring.
     * @return nameNotLike
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_NAME_NOT_LIKE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getNameNotLike() {
        return nameNotLike;
    }

    @JsonProperty(JSON_PROPERTY_NAME_NOT_LIKE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setNameNotLike(String nameNotLike) {
        this.nameNotLike = nameNotLike;
    }

    public TaskQueryDto description(String description) {
        this.description = description;
        return this;
    }

    /**
     * Restrict to tasks that have the given description.
     * @return description
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_DESCRIPTION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getDescription() {
        return description;
    }

    @JsonProperty(JSON_PROPERTY_DESCRIPTION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setDescription(String description) {
        this.description = description;
    }

    public TaskQueryDto descriptionLike(String descriptionLike) {
        this.descriptionLike = descriptionLike;
        return this;
    }

    /**
     * Restrict to tasks that have a description that has the parameter value as a substring.
     * @return descriptionLike
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_DESCRIPTION_LIKE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getDescriptionLike() {
        return descriptionLike;
    }

    @JsonProperty(JSON_PROPERTY_DESCRIPTION_LIKE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setDescriptionLike(String descriptionLike) {
        this.descriptionLike = descriptionLike;
    }

    public TaskQueryDto priority(Integer priority) {
        this.priority = priority;
        return this;
    }

    /**
     * Restrict to tasks that have the given priority.
     * @return priority
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_PRIORITY)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Integer getPriority() {
        return priority;
    }

    @JsonProperty(JSON_PROPERTY_PRIORITY)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setPriority(Integer priority) {
        this.priority = priority;
    }

    public TaskQueryDto maxPriority(Integer maxPriority) {
        this.maxPriority = maxPriority;
        return this;
    }

    /**
     * Restrict to tasks that have a lower or equal priority.
     * @return maxPriority
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_MAX_PRIORITY)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Integer getMaxPriority() {
        return maxPriority;
    }

    @JsonProperty(JSON_PROPERTY_MAX_PRIORITY)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setMaxPriority(Integer maxPriority) {
        this.maxPriority = maxPriority;
    }

    public TaskQueryDto minPriority(Integer minPriority) {
        this.minPriority = minPriority;
        return this;
    }

    /**
     * Restrict to tasks that have a higher or equal priority.
     * @return minPriority
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_MIN_PRIORITY)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Integer getMinPriority() {
        return minPriority;
    }

    @JsonProperty(JSON_PROPERTY_MIN_PRIORITY)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setMinPriority(Integer minPriority) {
        this.minPriority = minPriority;
    }

    public TaskQueryDto dueDate(OffsetDateTime dueDate) {
        this.dueDate = dueDate;
        return this;
    }

    /**
     * Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @return dueDate
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_DUE_DATE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXX")
    public OffsetDateTime getDueDate() {
        return dueDate;
    }

    @JsonProperty(JSON_PROPERTY_DUE_DATE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXX")
    public void setDueDate(OffsetDateTime dueDate) {
        this.dueDate = dueDate;
    }

    public TaskQueryDto dueDateExpression(String dueDateExpression) {
        this.dueDateExpression = dueDateExpression;
        return this;
    }

    /**
     * Restrict to tasks that are due on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @return dueDateExpression
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_DUE_DATE_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getDueDateExpression() {
        return dueDateExpression;
    }

    @JsonProperty(JSON_PROPERTY_DUE_DATE_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setDueDateExpression(String dueDateExpression) {
        this.dueDateExpression = dueDateExpression;
    }

    public TaskQueryDto dueAfter(OffsetDateTime dueAfter) {
        this.dueAfter = dueAfter;
        return this;
    }

    /**
     * Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
     * @return dueAfter
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_DUE_AFTER)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXX")
    public OffsetDateTime getDueAfter() {
        return dueAfter;
    }

    @JsonProperty(JSON_PROPERTY_DUE_AFTER)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXX")
    public void setDueAfter(OffsetDateTime dueAfter) {
        this.dueAfter = dueAfter;
    }

    public TaskQueryDto dueAfterExpression(String dueAfterExpression) {
        this.dueAfterExpression = dueAfterExpression;
        return this;
    }

    /**
     * Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @return dueAfterExpression
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_DUE_AFTER_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getDueAfterExpression() {
        return dueAfterExpression;
    }

    @JsonProperty(JSON_PROPERTY_DUE_AFTER_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setDueAfterExpression(String dueAfterExpression) {
        this.dueAfterExpression = dueAfterExpression;
    }

    public TaskQueryDto dueBefore(OffsetDateTime dueBefore) {
        this.dueBefore = dueBefore;
        return this;
    }

    /**
     * Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
     * @return dueBefore
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_DUE_BEFORE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXX")
    public OffsetDateTime getDueBefore() {
        return dueBefore;
    }

    @JsonProperty(JSON_PROPERTY_DUE_BEFORE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXX")
    public void setDueBefore(OffsetDateTime dueBefore) {
        this.dueBefore = dueBefore;
    }

    public TaskQueryDto dueBeforeExpression(String dueBeforeExpression) {
        this.dueBeforeExpression = dueBeforeExpression;
        return this;
    }

    /**
     * Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @return dueBeforeExpression
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_DUE_BEFORE_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getDueBeforeExpression() {
        return dueBeforeExpression;
    }

    @JsonProperty(JSON_PROPERTY_DUE_BEFORE_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setDueBeforeExpression(String dueBeforeExpression) {
        this.dueBeforeExpression = dueBeforeExpression;
    }

    public TaskQueryDto withoutDueDate(Boolean withoutDueDate) {
        this.withoutDueDate = withoutDueDate;
        return this;
    }

    /**
     * Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
     * @return withoutDueDate
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_WITHOUT_DUE_DATE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Boolean getWithoutDueDate() {
        return withoutDueDate;
    }

    @JsonProperty(JSON_PROPERTY_WITHOUT_DUE_DATE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setWithoutDueDate(Boolean withoutDueDate) {
        this.withoutDueDate = withoutDueDate;
    }

    public TaskQueryDto followUpDate(OffsetDateTime followUpDate) {
        this.followUpDate = followUpDate;
        return this;
    }

    /**
     * Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
     * @return followUpDate
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_FOLLOW_UP_DATE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXX")
    public OffsetDateTime getFollowUpDate() {
        return followUpDate;
    }

    @JsonProperty(JSON_PROPERTY_FOLLOW_UP_DATE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXX")
    public void setFollowUpDate(OffsetDateTime followUpDate) {
        this.followUpDate = followUpDate;
    }

    public TaskQueryDto followUpDateExpression(String followUpDateExpression) {
        this.followUpDateExpression = followUpDateExpression;
        return this;
    }

    /**
     * Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @return followUpDateExpression
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_FOLLOW_UP_DATE_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getFollowUpDateExpression() {
        return followUpDateExpression;
    }

    @JsonProperty(JSON_PROPERTY_FOLLOW_UP_DATE_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setFollowUpDateExpression(String followUpDateExpression) {
        this.followUpDateExpression = followUpDateExpression;
    }

    public TaskQueryDto followUpAfter(OffsetDateTime followUpAfter) {
        this.followUpAfter = followUpAfter;
        return this;
    }

    /**
     * Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
     * @return followUpAfter
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_FOLLOW_UP_AFTER)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXX")
    public OffsetDateTime getFollowUpAfter() {
        return followUpAfter;
    }

    @JsonProperty(JSON_PROPERTY_FOLLOW_UP_AFTER)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXX")
    public void setFollowUpAfter(OffsetDateTime followUpAfter) {
        this.followUpAfter = followUpAfter;
    }

    public TaskQueryDto followUpAfterExpression(String followUpAfterExpression) {
        this.followUpAfterExpression = followUpAfterExpression;
        return this;
    }

    /**
     * Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @return followUpAfterExpression
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_FOLLOW_UP_AFTER_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getFollowUpAfterExpression() {
        return followUpAfterExpression;
    }

    @JsonProperty(JSON_PROPERTY_FOLLOW_UP_AFTER_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setFollowUpAfterExpression(String followUpAfterExpression) {
        this.followUpAfterExpression = followUpAfterExpression;
    }

    public TaskQueryDto followUpBefore(String followUpBefore) {
        this.followUpBefore = followUpBefore;
        return this;
    }

    /**
     * Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
     * @return followUpBefore
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_FOLLOW_UP_BEFORE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getFollowUpBefore() {
        return followUpBefore;
    }

    @JsonProperty(JSON_PROPERTY_FOLLOW_UP_BEFORE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setFollowUpBefore(String followUpBefore) {
        this.followUpBefore = followUpBefore;
    }

    public TaskQueryDto followUpBeforeExpression(String followUpBeforeExpression) {
        this.followUpBeforeExpression = followUpBeforeExpression;
        return this;
    }

    /**
     * Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @return followUpBeforeExpression
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_FOLLOW_UP_BEFORE_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getFollowUpBeforeExpression() {
        return followUpBeforeExpression;
    }

    @JsonProperty(JSON_PROPERTY_FOLLOW_UP_BEFORE_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setFollowUpBeforeExpression(String followUpBeforeExpression) {
        this.followUpBeforeExpression = followUpBeforeExpression;
    }

    public TaskQueryDto followUpBeforeOrNotExistent(OffsetDateTime followUpBeforeOrNotExistent) {
        this.followUpBeforeOrNotExistent = followUpBeforeOrNotExistent;
        return this;
    }

    /**
     * Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
     * @return followUpBeforeOrNotExistent
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_FOLLOW_UP_BEFORE_OR_NOT_EXISTENT)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXX")
    public OffsetDateTime getFollowUpBeforeOrNotExistent() {
        return followUpBeforeOrNotExistent;
    }

    @JsonProperty(JSON_PROPERTY_FOLLOW_UP_BEFORE_OR_NOT_EXISTENT)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXX")
    public void setFollowUpBeforeOrNotExistent(OffsetDateTime followUpBeforeOrNotExistent) {
        this.followUpBeforeOrNotExistent = followUpBeforeOrNotExistent;
    }

    public TaskQueryDto followUpBeforeOrNotExistentExpression(String followUpBeforeOrNotExistentExpression) {
        this.followUpBeforeOrNotExistentExpression = followUpBeforeOrNotExistentExpression;
        return this;
    }

    /**
     * Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @return followUpBeforeOrNotExistentExpression
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_FOLLOW_UP_BEFORE_OR_NOT_EXISTENT_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getFollowUpBeforeOrNotExistentExpression() {
        return followUpBeforeOrNotExistentExpression;
    }

    @JsonProperty(JSON_PROPERTY_FOLLOW_UP_BEFORE_OR_NOT_EXISTENT_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setFollowUpBeforeOrNotExistentExpression(String followUpBeforeOrNotExistentExpression) {
        this.followUpBeforeOrNotExistentExpression = followUpBeforeOrNotExistentExpression;
    }

    public TaskQueryDto createdOn(OffsetDateTime createdOn) {
        this.createdOn = createdOn;
        return this;
    }

    /**
     * Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
     * @return createdOn
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CREATED_ON)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXX")
    public OffsetDateTime getCreatedOn() {
        return createdOn;
    }

    @JsonProperty(JSON_PROPERTY_CREATED_ON)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXX")
    public void setCreatedOn(OffsetDateTime createdOn) {
        this.createdOn = createdOn;
    }

    public TaskQueryDto createdOnExpression(String createdOnExpression) {
        this.createdOnExpression = createdOnExpression;
        return this;
    }

    /**
     * Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @return createdOnExpression
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CREATED_ON_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getCreatedOnExpression() {
        return createdOnExpression;
    }

    @JsonProperty(JSON_PROPERTY_CREATED_ON_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setCreatedOnExpression(String createdOnExpression) {
        this.createdOnExpression = createdOnExpression;
    }

    public TaskQueryDto createdAfter(OffsetDateTime createdAfter) {
        this.createdAfter = createdAfter;
        return this;
    }

    /**
     * Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
     * @return createdAfter
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CREATED_AFTER)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXX")
    public OffsetDateTime getCreatedAfter() {
        return createdAfter;
    }

    @JsonProperty(JSON_PROPERTY_CREATED_AFTER)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXX")
    public void setCreatedAfter(OffsetDateTime createdAfter) {
        this.createdAfter = createdAfter;
    }

    public TaskQueryDto createdAfterExpression(String createdAfterExpression) {
        this.createdAfterExpression = createdAfterExpression;
        return this;
    }

    /**
     * Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @return createdAfterExpression
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CREATED_AFTER_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getCreatedAfterExpression() {
        return createdAfterExpression;
    }

    @JsonProperty(JSON_PROPERTY_CREATED_AFTER_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setCreatedAfterExpression(String createdAfterExpression) {
        this.createdAfterExpression = createdAfterExpression;
    }

    public TaskQueryDto createdBefore(OffsetDateTime createdBefore) {
        this.createdBefore = createdBefore;
        return this;
    }

    /**
     * Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
     * @return createdBefore
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CREATED_BEFORE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXX")
    public OffsetDateTime getCreatedBefore() {
        return createdBefore;
    }

    @JsonProperty(JSON_PROPERTY_CREATED_BEFORE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXX")
    public void setCreatedBefore(OffsetDateTime createdBefore) {
        this.createdBefore = createdBefore;
    }

    public TaskQueryDto createdBeforeExpression(String createdBeforeExpression) {
        this.createdBeforeExpression = createdBeforeExpression;
        return this;
    }

    /**
     * Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @return createdBeforeExpression
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CREATED_BEFORE_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getCreatedBeforeExpression() {
        return createdBeforeExpression;
    }

    @JsonProperty(JSON_PROPERTY_CREATED_BEFORE_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setCreatedBeforeExpression(String createdBeforeExpression) {
        this.createdBeforeExpression = createdBeforeExpression;
    }

    public TaskQueryDto updatedAfter(OffsetDateTime updatedAfter) {
        this.updatedAfter = updatedAfter;
        return this;
    }

    /**
     * Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.18/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
     * @return updatedAfter
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_UPDATED_AFTER)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXX")
    public OffsetDateTime getUpdatedAfter() {
        return updatedAfter;
    }

    @JsonProperty(JSON_PROPERTY_UPDATED_AFTER)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXX")
    public void setUpdatedAfter(OffsetDateTime updatedAfter) {
        this.updatedAfter = updatedAfter;
    }

    public TaskQueryDto updatedAfterExpression(String updatedAfterExpression) {
        this.updatedAfterExpression = updatedAfterExpression;
        return this;
    }

    /**
     * Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.18/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @return updatedAfterExpression
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_UPDATED_AFTER_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getUpdatedAfterExpression() {
        return updatedAfterExpression;
    }

    @JsonProperty(JSON_PROPERTY_UPDATED_AFTER_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setUpdatedAfterExpression(String updatedAfterExpression) {
        this.updatedAfterExpression = updatedAfterExpression;
    }

    public TaskQueryDto delegationState(DelegationStateEnum delegationState) {
        this.delegationState = delegationState;
        return this;
    }

    /**
     * Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
     * @return delegationState
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_DELEGATION_STATE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public DelegationStateEnum getDelegationState() {
        return delegationState;
    }

    @JsonProperty(JSON_PROPERTY_DELEGATION_STATE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setDelegationState(DelegationStateEnum delegationState) {
        this.delegationState = delegationState;
    }

    public TaskQueryDto candidateGroups(List<String> candidateGroups) {
        this.candidateGroups = candidateGroups;
        return this;
    }

    public TaskQueryDto addCandidateGroupsItem(String candidateGroupsItem) {
        if (this.candidateGroups == null) {
            this.candidateGroups = new ArrayList<>();
        }
        this.candidateGroups.add(candidateGroupsItem);
        return this;
    }

    /**
     * Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
     * @return candidateGroups
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CANDIDATE_GROUPS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public List<String> getCandidateGroups() {
        return candidateGroups;
    }

    @JsonProperty(JSON_PROPERTY_CANDIDATE_GROUPS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setCandidateGroups(List<String> candidateGroups) {
        this.candidateGroups = candidateGroups;
    }

    public TaskQueryDto candidateGroupsExpression(String candidateGroupsExpression) {
        this.candidateGroupsExpression = candidateGroupsExpression;
        return this;
    }

    /**
     * Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
     * @return candidateGroupsExpression
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CANDIDATE_GROUPS_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getCandidateGroupsExpression() {
        return candidateGroupsExpression;
    }

    @JsonProperty(JSON_PROPERTY_CANDIDATE_GROUPS_EXPRESSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setCandidateGroupsExpression(String candidateGroupsExpression) {
        this.candidateGroupsExpression = candidateGroupsExpression;
    }

    public TaskQueryDto withCandidateGroups(Boolean withCandidateGroups) {
        this.withCandidateGroups = withCandidateGroups;
        return this;
    }

    /**
     * Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @return withCandidateGroups
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_WITH_CANDIDATE_GROUPS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Boolean getWithCandidateGroups() {
        return withCandidateGroups;
    }

    @JsonProperty(JSON_PROPERTY_WITH_CANDIDATE_GROUPS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setWithCandidateGroups(Boolean withCandidateGroups) {
        this.withCandidateGroups = withCandidateGroups;
    }

    public TaskQueryDto withoutCandidateGroups(Boolean withoutCandidateGroups) {
        this.withoutCandidateGroups = withoutCandidateGroups;
        return this;
    }

    /**
     * Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @return withoutCandidateGroups
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_WITHOUT_CANDIDATE_GROUPS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Boolean getWithoutCandidateGroups() {
        return withoutCandidateGroups;
    }

    @JsonProperty(JSON_PROPERTY_WITHOUT_CANDIDATE_GROUPS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setWithoutCandidateGroups(Boolean withoutCandidateGroups) {
        this.withoutCandidateGroups = withoutCandidateGroups;
    }

    public TaskQueryDto withCandidateUsers(Boolean withCandidateUsers) {
        this.withCandidateUsers = withCandidateUsers;
        return this;
    }

    /**
     * Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @return withCandidateUsers
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_WITH_CANDIDATE_USERS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Boolean getWithCandidateUsers() {
        return withCandidateUsers;
    }

    @JsonProperty(JSON_PROPERTY_WITH_CANDIDATE_USERS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setWithCandidateUsers(Boolean withCandidateUsers) {
        this.withCandidateUsers = withCandidateUsers;
    }

    public TaskQueryDto withoutCandidateUsers(Boolean withoutCandidateUsers) {
        this.withoutCandidateUsers = withoutCandidateUsers;
        return this;
    }

    /**
     * Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @return withoutCandidateUsers
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_WITHOUT_CANDIDATE_USERS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Boolean getWithoutCandidateUsers() {
        return withoutCandidateUsers;
    }

    @JsonProperty(JSON_PROPERTY_WITHOUT_CANDIDATE_USERS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setWithoutCandidateUsers(Boolean withoutCandidateUsers) {
        this.withoutCandidateUsers = withoutCandidateUsers;
    }

    public TaskQueryDto active(Boolean active) {
        this.active = active;
        return this;
    }

    /**
     * Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @return active
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_ACTIVE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Boolean getActive() {
        return active;
    }

    @JsonProperty(JSON_PROPERTY_ACTIVE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setActive(Boolean active) {
        this.active = active;
    }

    public TaskQueryDto suspended(Boolean suspended) {
        this.suspended = suspended;
        return this;
    }

    /**
     * Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @return suspended
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_SUSPENDED)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Boolean getSuspended() {
        return suspended;
    }

    @JsonProperty(JSON_PROPERTY_SUSPENDED)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setSuspended(Boolean suspended) {
        this.suspended = suspended;
    }

    public TaskQueryDto taskVariables(List<VariableQueryParameterDto> taskVariables) {
        this.taskVariables = taskVariables;
        return this;
    }

    public TaskQueryDto addTaskVariablesItem(VariableQueryParameterDto taskVariablesItem) {
        if (this.taskVariables == null) {
            this.taskVariables = new ArrayList<>();
        }
        this.taskVariables.add(taskVariablesItem);
        return this;
    }

    /**
     * A JSON array to only include tasks that have variables with certain values. The array consists of JSON objects with three properties &#x60;name&#x60;, &#x60;operator&#x60; and &#x60;value&#x60;. &#x60;name&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. &#x60;value&#x60; may be of type &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @return taskVariables
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_TASK_VARIABLES)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public List<VariableQueryParameterDto> getTaskVariables() {
        return taskVariables;
    }

    @JsonProperty(JSON_PROPERTY_TASK_VARIABLES)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setTaskVariables(List<VariableQueryParameterDto> taskVariables) {
        this.taskVariables = taskVariables;
    }

    public TaskQueryDto processVariables(List<VariableQueryParameterDto> processVariables) {
        this.processVariables = processVariables;
        return this;
    }

    public TaskQueryDto addProcessVariablesItem(VariableQueryParameterDto processVariablesItem) {
        if (this.processVariables == null) {
            this.processVariables = new ArrayList<>();
        }
        this.processVariables.add(processVariablesItem);
        return this;
    }

    /**
     * A JSON array to only include tasks that belong to a process instance with variables with certain values. The array consists of JSON objects with three properties &#x60;name&#x60;, &#x60;operator&#x60; and &#x60;value&#x60;. &#x60;name&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. &#x60;value&#x60; may be of type &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @return processVariables
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_PROCESS_VARIABLES)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public List<VariableQueryParameterDto> getProcessVariables() {
        return processVariables;
    }

    @JsonProperty(JSON_PROPERTY_PROCESS_VARIABLES)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setProcessVariables(List<VariableQueryParameterDto> processVariables) {
        this.processVariables = processVariables;
    }

    public TaskQueryDto caseInstanceVariables(List<VariableQueryParameterDto> caseInstanceVariables) {
        this.caseInstanceVariables = caseInstanceVariables;
        return this;
    }

    public TaskQueryDto addCaseInstanceVariablesItem(VariableQueryParameterDto caseInstanceVariablesItem) {
        if (this.caseInstanceVariables == null) {
            this.caseInstanceVariables = new ArrayList<>();
        }
        this.caseInstanceVariables.add(caseInstanceVariablesItem);
        return this;
    }

    /**
     * A JSON array to only include tasks that belong to a case instance with variables with certain values. The array consists of JSON objects with three properties &#x60;name&#x60;, &#x60;operator&#x60; and &#x60;value&#x60;. &#x60;name&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. &#x60;value&#x60; may be of type &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @return caseInstanceVariables
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_CASE_INSTANCE_VARIABLES)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public List<VariableQueryParameterDto> getCaseInstanceVariables() {
        return caseInstanceVariables;
    }

    @JsonProperty(JSON_PROPERTY_CASE_INSTANCE_VARIABLES)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setCaseInstanceVariables(List<VariableQueryParameterDto> caseInstanceVariables) {
        this.caseInstanceVariables = caseInstanceVariables;
    }

    public TaskQueryDto variableNamesIgnoreCase(Boolean variableNamesIgnoreCase) {
        this.variableNamesIgnoreCase = variableNamesIgnoreCase;
        return this;
    }

    /**
     * Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
     * @return variableNamesIgnoreCase
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_VARIABLE_NAMES_IGNORE_CASE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Boolean getVariableNamesIgnoreCase() {
        return variableNamesIgnoreCase;
    }

    @JsonProperty(JSON_PROPERTY_VARIABLE_NAMES_IGNORE_CASE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setVariableNamesIgnoreCase(Boolean variableNamesIgnoreCase) {
        this.variableNamesIgnoreCase = variableNamesIgnoreCase;
    }

    public TaskQueryDto variableValuesIgnoreCase(Boolean variableValuesIgnoreCase) {
        this.variableValuesIgnoreCase = variableValuesIgnoreCase;
        return this;
    }

    /**
     * Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
     * @return variableValuesIgnoreCase
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_VARIABLE_VALUES_IGNORE_CASE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Boolean getVariableValuesIgnoreCase() {
        return variableValuesIgnoreCase;
    }

    @JsonProperty(JSON_PROPERTY_VARIABLE_VALUES_IGNORE_CASE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setVariableValuesIgnoreCase(Boolean variableValuesIgnoreCase) {
        this.variableValuesIgnoreCase = variableValuesIgnoreCase;
    }

    public TaskQueryDto parentTaskId(String parentTaskId) {
        this.parentTaskId = parentTaskId;
        return this;
    }

    /**
     * Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
     * @return parentTaskId
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_PARENT_TASK_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getParentTaskId() {
        return parentTaskId;
    }

    @JsonProperty(JSON_PROPERTY_PARENT_TASK_ID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setParentTaskId(String parentTaskId) {
        this.parentTaskId = parentTaskId;
    }

    public TaskQueryDto orQueries(List<TaskQueryDto> orQueries) {
        this.orQueries = orQueries;
        return this;
    }

    public TaskQueryDto addOrQueriesItem(TaskQueryDto orQueriesItem) {
        if (this.orQueries == null) {
            this.orQueries = new ArrayList<>();
        }
        this.orQueries.add(orQueriesItem);
        return this;
    }

    /**
     * A JSON array of nested task queries with OR semantics. A task matches a nested query if it fulfills *at least one* of the query&#39;s predicates. With multiple nested queries, a task must fulfill at least one predicate of *each* query ([Conjunctive Normal Form](https://en.wikipedia.org/wiki/Conjunctive_normal_form)).  All task query properties can be used except for: &#x60;sorting&#x60;, &#x60;withCandidateGroups&#x60;, &#x60;withoutCandidateGroups&#x60;, &#x60;withCandidateUsers&#x60;, &#x60;withoutCandidateUsers&#x60;  See the [User guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/process-engine-api/#or-queries) for more information about OR queries.
     * @return orQueries
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_OR_QUERIES)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public List<TaskQueryDto> getOrQueries() {
        return orQueries;
    }

    @JsonProperty(JSON_PROPERTY_OR_QUERIES)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setOrQueries(List<TaskQueryDto> orQueries) {
        this.orQueries = orQueries;
    }

    public TaskQueryDto sorting(List<TaskQueryDtoSortingInner> sorting) {
        this.sorting = sorting;
        return this;
    }

    public TaskQueryDto addSortingItem(TaskQueryDtoSortingInner sortingItem) {
        if (this.sorting == null) {
            this.sorting = new ArrayList<>();
        }
        this.sorting.add(sortingItem);
        return this;
    }

    /**
     * Apply sorting of the result
     * @return sorting
     **/
    @Nullable
    @JsonProperty(JSON_PROPERTY_SORTING)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public List<TaskQueryDtoSortingInner> getSorting() {
        return sorting;
    }

    @JsonProperty(JSON_PROPERTY_SORTING)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setSorting(List<TaskQueryDtoSortingInner> sorting) {
        this.sorting = sorting;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        TaskQueryDto taskQueryDto = (TaskQueryDto) o;
        return Objects.equals(this.taskId, taskQueryDto.taskId) &&
            Objects.equals(this.taskIdIn, taskQueryDto.taskIdIn) &&
            Objects.equals(this.processInstanceId, taskQueryDto.processInstanceId) &&
            Objects.equals(this.processInstanceIdIn, taskQueryDto.processInstanceIdIn) &&
            Objects.equals(this.processInstanceBusinessKey, taskQueryDto.processInstanceBusinessKey) &&
            Objects.equals(this.processInstanceBusinessKeyExpression, taskQueryDto.processInstanceBusinessKeyExpression) &&
            Objects.equals(this.processInstanceBusinessKeyIn, taskQueryDto.processInstanceBusinessKeyIn) &&
            Objects.equals(this.processInstanceBusinessKeyLike, taskQueryDto.processInstanceBusinessKeyLike) &&
            Objects.equals(this.processInstanceBusinessKeyLikeExpression, taskQueryDto.processInstanceBusinessKeyLikeExpression) &&
            Objects.equals(this.processDefinitionId, taskQueryDto.processDefinitionId) &&
            Objects.equals(this.processDefinitionKey, taskQueryDto.processDefinitionKey) &&
            Objects.equals(this.processDefinitionKeyIn, taskQueryDto.processDefinitionKeyIn) &&
            Objects.equals(this.processDefinitionName, taskQueryDto.processDefinitionName) &&
            Objects.equals(this.processDefinitionNameLike, taskQueryDto.processDefinitionNameLike) &&
            Objects.equals(this.executionId, taskQueryDto.executionId) &&
            Objects.equals(this.caseInstanceId, taskQueryDto.caseInstanceId) &&
            Objects.equals(this.caseInstanceBusinessKey, taskQueryDto.caseInstanceBusinessKey) &&
            Objects.equals(this.caseInstanceBusinessKeyLike, taskQueryDto.caseInstanceBusinessKeyLike) &&
            Objects.equals(this.caseDefinitionId, taskQueryDto.caseDefinitionId) &&
            Objects.equals(this.caseDefinitionKey, taskQueryDto.caseDefinitionKey) &&
            Objects.equals(this.caseDefinitionName, taskQueryDto.caseDefinitionName) &&
            Objects.equals(this.caseDefinitionNameLike, taskQueryDto.caseDefinitionNameLike) &&
            Objects.equals(this.caseExecutionId, taskQueryDto.caseExecutionId) &&
            Objects.equals(this.activityInstanceIdIn, taskQueryDto.activityInstanceIdIn) &&
            Objects.equals(this.tenantIdIn, taskQueryDto.tenantIdIn) &&
            Objects.equals(this.withoutTenantId, taskQueryDto.withoutTenantId) &&
            Objects.equals(this.assignee, taskQueryDto.assignee) &&
            Objects.equals(this.assigneeExpression, taskQueryDto.assigneeExpression) &&
            Objects.equals(this.assigneeLike, taskQueryDto.assigneeLike) &&
            Objects.equals(this.assigneeLikeExpression, taskQueryDto.assigneeLikeExpression) &&
            Objects.equals(this.assigneeIn, taskQueryDto.assigneeIn) &&
            Objects.equals(this.assigneeNotIn, taskQueryDto.assigneeNotIn) &&
            Objects.equals(this.owner, taskQueryDto.owner) &&
            Objects.equals(this.ownerExpression, taskQueryDto.ownerExpression) &&
            Objects.equals(this.candidateGroup, taskQueryDto.candidateGroup) &&
            Objects.equals(this.candidateGroupExpression, taskQueryDto.candidateGroupExpression) &&
            Objects.equals(this.candidateUser, taskQueryDto.candidateUser) &&
            Objects.equals(this.candidateUserExpression, taskQueryDto.candidateUserExpression) &&
            Objects.equals(this.includeAssignedTasks, taskQueryDto.includeAssignedTasks) &&
            Objects.equals(this.involvedUser, taskQueryDto.involvedUser) &&
            Objects.equals(this.involvedUserExpression, taskQueryDto.involvedUserExpression) &&
            Objects.equals(this.assigned, taskQueryDto.assigned) &&
            Objects.equals(this.unassigned, taskQueryDto.unassigned) &&
            Objects.equals(this.taskDefinitionKey, taskQueryDto.taskDefinitionKey) &&
            Objects.equals(this.taskDefinitionKeyIn, taskQueryDto.taskDefinitionKeyIn) &&
            Objects.equals(this.taskDefinitionKeyLike, taskQueryDto.taskDefinitionKeyLike) &&
            Objects.equals(this.name, taskQueryDto.name) &&
            Objects.equals(this.nameNotEqual, taskQueryDto.nameNotEqual) &&
            Objects.equals(this.nameLike, taskQueryDto.nameLike) &&
            Objects.equals(this.nameNotLike, taskQueryDto.nameNotLike) &&
            Objects.equals(this.description, taskQueryDto.description) &&
            Objects.equals(this.descriptionLike, taskQueryDto.descriptionLike) &&
            Objects.equals(this.priority, taskQueryDto.priority) &&
            Objects.equals(this.maxPriority, taskQueryDto.maxPriority) &&
            Objects.equals(this.minPriority, taskQueryDto.minPriority) &&
            Objects.equals(this.dueDate, taskQueryDto.dueDate) &&
            Objects.equals(this.dueDateExpression, taskQueryDto.dueDateExpression) &&
            Objects.equals(this.dueAfter, taskQueryDto.dueAfter) &&
            Objects.equals(this.dueAfterExpression, taskQueryDto.dueAfterExpression) &&
            Objects.equals(this.dueBefore, taskQueryDto.dueBefore) &&
            Objects.equals(this.dueBeforeExpression, taskQueryDto.dueBeforeExpression) &&
            Objects.equals(this.withoutDueDate, taskQueryDto.withoutDueDate) &&
            Objects.equals(this.followUpDate, taskQueryDto.followUpDate) &&
            Objects.equals(this.followUpDateExpression, taskQueryDto.followUpDateExpression) &&
            Objects.equals(this.followUpAfter, taskQueryDto.followUpAfter) &&
            Objects.equals(this.followUpAfterExpression, taskQueryDto.followUpAfterExpression) &&
            Objects.equals(this.followUpBefore, taskQueryDto.followUpBefore) &&
            Objects.equals(this.followUpBeforeExpression, taskQueryDto.followUpBeforeExpression) &&
            Objects.equals(this.followUpBeforeOrNotExistent, taskQueryDto.followUpBeforeOrNotExistent) &&
            Objects.equals(this.followUpBeforeOrNotExistentExpression, taskQueryDto.followUpBeforeOrNotExistentExpression) &&
            Objects.equals(this.createdOn, taskQueryDto.createdOn) &&
            Objects.equals(this.createdOnExpression, taskQueryDto.createdOnExpression) &&
            Objects.equals(this.createdAfter, taskQueryDto.createdAfter) &&
            Objects.equals(this.createdAfterExpression, taskQueryDto.createdAfterExpression) &&
            Objects.equals(this.createdBefore, taskQueryDto.createdBefore) &&
            Objects.equals(this.createdBeforeExpression, taskQueryDto.createdBeforeExpression) &&
            Objects.equals(this.updatedAfter, taskQueryDto.updatedAfter) &&
            Objects.equals(this.updatedAfterExpression, taskQueryDto.updatedAfterExpression) &&
            Objects.equals(this.delegationState, taskQueryDto.delegationState) &&
            Objects.equals(this.candidateGroups, taskQueryDto.candidateGroups) &&
            Objects.equals(this.candidateGroupsExpression, taskQueryDto.candidateGroupsExpression) &&
            Objects.equals(this.withCandidateGroups, taskQueryDto.withCandidateGroups) &&
            Objects.equals(this.withoutCandidateGroups, taskQueryDto.withoutCandidateGroups) &&
            Objects.equals(this.withCandidateUsers, taskQueryDto.withCandidateUsers) &&
            Objects.equals(this.withoutCandidateUsers, taskQueryDto.withoutCandidateUsers) &&
            Objects.equals(this.active, taskQueryDto.active) &&
            Objects.equals(this.suspended, taskQueryDto.suspended) &&
            Objects.equals(this.taskVariables, taskQueryDto.taskVariables) &&
            Objects.equals(this.processVariables, taskQueryDto.processVariables) &&
            Objects.equals(this.caseInstanceVariables, taskQueryDto.caseInstanceVariables) &&
            Objects.equals(this.variableNamesIgnoreCase, taskQueryDto.variableNamesIgnoreCase) &&
            Objects.equals(this.variableValuesIgnoreCase, taskQueryDto.variableValuesIgnoreCase) &&
            Objects.equals(this.parentTaskId, taskQueryDto.parentTaskId) &&
            Objects.equals(this.orQueries, taskQueryDto.orQueries) &&
            Objects.equals(this.sorting, taskQueryDto.sorting);
    }

    @Override
    public int hashCode() {
        return Objects.hash(taskId, taskIdIn, processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, assigneeNotIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, withoutDueDate, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, updatedAfter, updatedAfterExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, orQueries, sorting);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class TaskQueryDto {\n");
        sb.append("    taskId: ").append(toIndentedString(taskId)).append("\n");
        sb.append("    taskIdIn: ").append(toIndentedString(taskIdIn)).append("\n");
        sb.append("    processInstanceId: ").append(toIndentedString(processInstanceId)).append("\n");
        sb.append("    processInstanceIdIn: ").append(toIndentedString(processInstanceIdIn)).append("\n");
        sb.append("    processInstanceBusinessKey: ").append(toIndentedString(processInstanceBusinessKey)).append("\n");
        sb.append("    processInstanceBusinessKeyExpression: ").append(toIndentedString(processInstanceBusinessKeyExpression)).append("\n");
        sb.append("    processInstanceBusinessKeyIn: ").append(toIndentedString(processInstanceBusinessKeyIn)).append("\n");
        sb.append("    processInstanceBusinessKeyLike: ").append(toIndentedString(processInstanceBusinessKeyLike)).append("\n");
        sb.append("    processInstanceBusinessKeyLikeExpression: ").append(toIndentedString(processInstanceBusinessKeyLikeExpression)).append("\n");
        sb.append("    processDefinitionId: ").append(toIndentedString(processDefinitionId)).append("\n");
        sb.append("    processDefinitionKey: ").append(toIndentedString(processDefinitionKey)).append("\n");
        sb.append("    processDefinitionKeyIn: ").append(toIndentedString(processDefinitionKeyIn)).append("\n");
        sb.append("    processDefinitionName: ").append(toIndentedString(processDefinitionName)).append("\n");
        sb.append("    processDefinitionNameLike: ").append(toIndentedString(processDefinitionNameLike)).append("\n");
        sb.append("    executionId: ").append(toIndentedString(executionId)).append("\n");
        sb.append("    caseInstanceId: ").append(toIndentedString(caseInstanceId)).append("\n");
        sb.append("    caseInstanceBusinessKey: ").append(toIndentedString(caseInstanceBusinessKey)).append("\n");
        sb.append("    caseInstanceBusinessKeyLike: ").append(toIndentedString(caseInstanceBusinessKeyLike)).append("\n");
        sb.append("    caseDefinitionId: ").append(toIndentedString(caseDefinitionId)).append("\n");
        sb.append("    caseDefinitionKey: ").append(toIndentedString(caseDefinitionKey)).append("\n");
        sb.append("    caseDefinitionName: ").append(toIndentedString(caseDefinitionName)).append("\n");
        sb.append("    caseDefinitionNameLike: ").append(toIndentedString(caseDefinitionNameLike)).append("\n");
        sb.append("    caseExecutionId: ").append(toIndentedString(caseExecutionId)).append("\n");
        sb.append("    activityInstanceIdIn: ").append(toIndentedString(activityInstanceIdIn)).append("\n");
        sb.append("    tenantIdIn: ").append(toIndentedString(tenantIdIn)).append("\n");
        sb.append("    withoutTenantId: ").append(toIndentedString(withoutTenantId)).append("\n");
        sb.append("    assignee: ").append(toIndentedString(assignee)).append("\n");
        sb.append("    assigneeExpression: ").append(toIndentedString(assigneeExpression)).append("\n");
        sb.append("    assigneeLike: ").append(toIndentedString(assigneeLike)).append("\n");
        sb.append("    assigneeLikeExpression: ").append(toIndentedString(assigneeLikeExpression)).append("\n");
        sb.append("    assigneeIn: ").append(toIndentedString(assigneeIn)).append("\n");
        sb.append("    assigneeNotIn: ").append(toIndentedString(assigneeNotIn)).append("\n");
        sb.append("    owner: ").append(toIndentedString(owner)).append("\n");
        sb.append("    ownerExpression: ").append(toIndentedString(ownerExpression)).append("\n");
        sb.append("    candidateGroup: ").append(toIndentedString(candidateGroup)).append("\n");
        sb.append("    candidateGroupExpression: ").append(toIndentedString(candidateGroupExpression)).append("\n");
        sb.append("    candidateUser: ").append(toIndentedString(candidateUser)).append("\n");
        sb.append("    candidateUserExpression: ").append(toIndentedString(candidateUserExpression)).append("\n");
        sb.append("    includeAssignedTasks: ").append(toIndentedString(includeAssignedTasks)).append("\n");
        sb.append("    involvedUser: ").append(toIndentedString(involvedUser)).append("\n");
        sb.append("    involvedUserExpression: ").append(toIndentedString(involvedUserExpression)).append("\n");
        sb.append("    assigned: ").append(toIndentedString(assigned)).append("\n");
        sb.append("    unassigned: ").append(toIndentedString(unassigned)).append("\n");
        sb.append("    taskDefinitionKey: ").append(toIndentedString(taskDefinitionKey)).append("\n");
        sb.append("    taskDefinitionKeyIn: ").append(toIndentedString(taskDefinitionKeyIn)).append("\n");
        sb.append("    taskDefinitionKeyLike: ").append(toIndentedString(taskDefinitionKeyLike)).append("\n");
        sb.append("    name: ").append(toIndentedString(name)).append("\n");
        sb.append("    nameNotEqual: ").append(toIndentedString(nameNotEqual)).append("\n");
        sb.append("    nameLike: ").append(toIndentedString(nameLike)).append("\n");
        sb.append("    nameNotLike: ").append(toIndentedString(nameNotLike)).append("\n");
        sb.append("    description: ").append(toIndentedString(description)).append("\n");
        sb.append("    descriptionLike: ").append(toIndentedString(descriptionLike)).append("\n");
        sb.append("    priority: ").append(toIndentedString(priority)).append("\n");
        sb.append("    maxPriority: ").append(toIndentedString(maxPriority)).append("\n");
        sb.append("    minPriority: ").append(toIndentedString(minPriority)).append("\n");
        sb.append("    dueDate: ").append(toIndentedString(dueDate)).append("\n");
        sb.append("    dueDateExpression: ").append(toIndentedString(dueDateExpression)).append("\n");
        sb.append("    dueAfter: ").append(toIndentedString(dueAfter)).append("\n");
        sb.append("    dueAfterExpression: ").append(toIndentedString(dueAfterExpression)).append("\n");
        sb.append("    dueBefore: ").append(toIndentedString(dueBefore)).append("\n");
        sb.append("    dueBeforeExpression: ").append(toIndentedString(dueBeforeExpression)).append("\n");
        sb.append("    withoutDueDate: ").append(toIndentedString(withoutDueDate)).append("\n");
        sb.append("    followUpDate: ").append(toIndentedString(followUpDate)).append("\n");
        sb.append("    followUpDateExpression: ").append(toIndentedString(followUpDateExpression)).append("\n");
        sb.append("    followUpAfter: ").append(toIndentedString(followUpAfter)).append("\n");
        sb.append("    followUpAfterExpression: ").append(toIndentedString(followUpAfterExpression)).append("\n");
        sb.append("    followUpBefore: ").append(toIndentedString(followUpBefore)).append("\n");
        sb.append("    followUpBeforeExpression: ").append(toIndentedString(followUpBeforeExpression)).append("\n");
        sb.append("    followUpBeforeOrNotExistent: ").append(toIndentedString(followUpBeforeOrNotExistent)).append("\n");
        sb.append("    followUpBeforeOrNotExistentExpression: ").append(toIndentedString(followUpBeforeOrNotExistentExpression)).append("\n");
        sb.append("    createdOn: ").append(toIndentedString(createdOn)).append("\n");
        sb.append("    createdOnExpression: ").append(toIndentedString(createdOnExpression)).append("\n");
        sb.append("    createdAfter: ").append(toIndentedString(createdAfter)).append("\n");
        sb.append("    createdAfterExpression: ").append(toIndentedString(createdAfterExpression)).append("\n");
        sb.append("    createdBefore: ").append(toIndentedString(createdBefore)).append("\n");
        sb.append("    createdBeforeExpression: ").append(toIndentedString(createdBeforeExpression)).append("\n");
        sb.append("    updatedAfter: ").append(toIndentedString(updatedAfter)).append("\n");
        sb.append("    updatedAfterExpression: ").append(toIndentedString(updatedAfterExpression)).append("\n");
        sb.append("    delegationState: ").append(toIndentedString(delegationState)).append("\n");
        sb.append("    candidateGroups: ").append(toIndentedString(candidateGroups)).append("\n");
        sb.append("    candidateGroupsExpression: ").append(toIndentedString(candidateGroupsExpression)).append("\n");
        sb.append("    withCandidateGroups: ").append(toIndentedString(withCandidateGroups)).append("\n");
        sb.append("    withoutCandidateGroups: ").append(toIndentedString(withoutCandidateGroups)).append("\n");
        sb.append("    withCandidateUsers: ").append(toIndentedString(withCandidateUsers)).append("\n");
        sb.append("    withoutCandidateUsers: ").append(toIndentedString(withoutCandidateUsers)).append("\n");
        sb.append("    active: ").append(toIndentedString(active)).append("\n");
        sb.append("    suspended: ").append(toIndentedString(suspended)).append("\n");
        sb.append("    taskVariables: ").append(toIndentedString(taskVariables)).append("\n");
        sb.append("    processVariables: ").append(toIndentedString(processVariables)).append("\n");
        sb.append("    caseInstanceVariables: ").append(toIndentedString(caseInstanceVariables)).append("\n");
        sb.append("    variableNamesIgnoreCase: ").append(toIndentedString(variableNamesIgnoreCase)).append("\n");
        sb.append("    variableValuesIgnoreCase: ").append(toIndentedString(variableValuesIgnoreCase)).append("\n");
        sb.append("    parentTaskId: ").append(toIndentedString(parentTaskId)).append("\n");
        sb.append("    orQueries: ").append(toIndentedString(orQueries)).append("\n");
        sb.append("    sorting: ").append(toIndentedString(sorting)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }

}

